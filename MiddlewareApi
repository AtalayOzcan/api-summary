ASP.NET Coreâ€™da Middlewareâ€™e GiriÅŸ
1. GiriÅŸ
ASP.NET Coreâ€™da middleware (ara yazÄ±lÄ±m), gelen HTTP isteklerini karÅŸÄ±layan ve iÅŸleyen yazÄ±lÄ±m bileÅŸenlerinden oluÅŸan yapÄ±landÄ±rÄ±lmÄ±ÅŸ bir zincirdir. Bu bileÅŸenler, isteÄŸi adÄ±m adÄ±m iÅŸleyerek uygulama mantÄ±ÄŸÄ±na ulaÅŸmasÄ±nÄ± ve yanÄ±tÄ±n tekrar istemciye dÃ¶nmesini saÄŸlar. Her middlewareâ€™in belirli bir sorumluluÄŸu vardÄ±r; Ã¶rneÄŸin loglama, kimlik doÄŸrulama, hata yÃ¶netimi veya yÃ¶nlendirme.
Bu katmanlÄ± yapÄ± sayesinde uygulamalar daha modÃ¼ler, kolay yÃ¶netilebilir ve gÃ¼venli hale gelir.

2. Middleware Nedir?
Middleware, istemciden gelen bir HTTP isteÄŸini alÄ±r, belirli bir iÅŸlevi yerine getirir ve ardÄ±ndan isteÄŸi bir sonraki middlewareâ€™e iletir.
Bu yapÄ± sayesinde "sorumluluklarÄ±n ayrÄ±lmasÄ± (separation of concerns)" ilkesi uygulanÄ±r; her middleware sadece kendi gÃ¶revine odaklanÄ±r:

Loglama Middlewareâ€™i: KullanÄ±cÄ± etkileÅŸimlerini ve istek bilgilerini kaydeder.
Kimlik DoÄŸrulama Middlewareâ€™i: KullanÄ±cÄ±nÄ±n oturum bilgilerini kontrol eder, gerekli deÄŸilse isteÄŸi durdurur.
Yetkilendirme Middlewareâ€™i: KullanÄ±cÄ±nÄ±n belirli kaynaklara eriÅŸim izni olup olmadÄ±ÄŸÄ±nÄ± denetler.
Statik Dosya Middlewareâ€™i: GÃ¶rseller veya CSS gibi sabit iÃ§erikleri sunar.
YÃ¶nlendirme Middlewareâ€™i: Ä°steÄŸi uygun denetleyiciye (controller) yÃ¶nlendirir.
Bu sÄ±ralÄ± iÅŸleyiÅŸe middleware pipeline (ara yazÄ±lÄ±m iÅŸlem hattÄ±) adÄ± verilir.

3. Middleware Pipeline (Ä°ÅŸlem HattÄ±) NasÄ±l Ã‡alÄ±ÅŸÄ±r?
Middleware pipeline, bir HTTP isteÄŸinin uygulama iÃ§indeki tÃ¼m adÄ±mlardan geÃ§mesini saÄŸlayan zincirleme bir yapÄ±dÄ±r.
Ä°stek sunucuya gelir.
Ä°lk middleware bileÅŸeni isteÄŸi iÅŸler (Ã¶rneÄŸin loglama) ve bir sonraki bileÅŸene iletir.
Ä°ÅŸlem bu ÅŸekilde zincir halinde devam eder.
Uygulama mantÄ±ÄŸÄ± Ã§alÄ±ÅŸÄ±r ve yanÄ±t oluÅŸturulur.
YanÄ±t aynÄ± pipeline Ã¼zerinden geri dÃ¶ner ve her middleware Ã§Ä±karken de iÅŸleme katÄ±labilir (Ã¶rneÄŸin hata yÃ¶netimi veya response header ekleme).
Middleware sÄ±rasÄ± Ã§ok kritiktir. Ã–rneÄŸin, kimlik doÄŸrulama middlewareâ€™i veri eriÅŸiminden Ã¶nce Ã§alÄ±ÅŸmalÄ± ki sadece yetkili kullanÄ±cÄ±lar veriye ulaÅŸabilsin.

4. ASP.NET Coreâ€™da YerleÅŸik Middlewareâ€™ler
ASP.NET Core, birÃ§ok yaygÄ±n senaryoyu kolayca yÃ¶netebilmeniz iÃ§in yerleÅŸik middleware bileÅŸenleri sunar:

UseAuthentication
KullanÄ±cÄ±nÄ±n kimliÄŸini doÄŸrular. Oturum aÃ§ma kontrolleri bu katmanda yapÄ±lÄ±r.

UseAuthorization
KimliÄŸi doÄŸrulanan kullanÄ±cÄ±nÄ±n belirli kaynaklara eriÅŸimi olup olmadÄ±ÄŸÄ±nÄ± denetler.

UseRouting
Ä°steÄŸin hangi denetleyiciye veya sayfaya yÃ¶nlendirileceÄŸini belirler.

UseStaticFiles
CSS, JS, gÃ¶rsel gibi statik dosyalarÄ±n doÄŸrudan sunulmasÄ±nÄ± saÄŸlar.

UseExceptionHandler
HatalarÄ±n yakalanmasÄ± ve Ã¶zel hata sayfalarÄ±nÄ±n sunulmasÄ± iÃ§in kullanÄ±lÄ±r.
Bu bileÅŸenler, Startup.cs veya Program.cs iÃ§inde sÄ±rasÄ±yla tanÄ±mlanarak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

5. SonuÃ§
Middleware, ASP.NET Coreâ€™un temel yapÄ± taÅŸlarÄ±ndan biridir. HTTP isteklerini kÃ¼Ã§Ã¼k, yÃ¶netilebilir adÄ±mlara bÃ¶lerek daha anlaÅŸÄ±lÄ±r, gÃ¼venli ve bakÄ±mÄ± kolay uygulamalar geliÅŸtirmenize olanak tanÄ±r.
Ä°yi kurgulanmÄ±ÅŸ bir middleware zinciri, uygulama performansÄ±nÄ± artÄ±rÄ±r.
GÃ¼venlik, izlenebilirlik ve hata yÃ¶netimi gibi temel konular kontrol altÄ±na alÄ±nÄ±r.
GeliÅŸtiriciler, uygulamanÄ±n her adÄ±mÄ±nÄ± Ã¶zelleÅŸtirerek ihtiyaÃ§lara gÃ¶re uyarlayabilir.

ğŸš€ Middleware Nedir?
Middleware (ara yazÄ±lÄ±m), ASP.NET Core uygulamalarÄ±nda gelen HTTP isteklerini karÅŸÄ±layan ve iÅŸleyen bileÅŸenlerdir.
Her istek uygulamaya geldiÄŸinde, bir dizi middlewareâ€™den geÃ§erek yanÄ±t oluÅŸturulur. Bu bileÅŸenler uygulamanÄ±n gÃ¼venli, dÃ¼zenli ve kolay yÃ¶netilebilir olmasÄ±nÄ± saÄŸlar.

ğŸ“Œ Middlewareâ€™ler Nerede TanÄ±mlanÄ±r?
TÃ¼m middleware bileÅŸenleri Startup.cs dosyasÄ±nda tanÄ±mlanÄ±r. Bu dosya:

UygulamanÄ±n nasÄ±l baÅŸlatÄ±lacaÄŸÄ±nÄ± belirler,

Middleware sÄ±rasÄ±nÄ± yÃ¶netir,

Hangi servislerin kullanÄ±lacaÄŸÄ±nÄ± belirtir.

ğŸ”§ YaygÄ±n YerleÅŸik Middleware BileÅŸenleri ve KullanÄ±mÄ±
1. Hata YÃ¶netimi (Exception Handling)
AmaÃ§: Uygulama sÄ±rasÄ±nda oluÅŸan hatalarÄ± yakalayÄ±p kullanÄ±cÄ±ya teknik detaylar gÃ¶stermeden yÃ¶nlendirmek.

KullanÄ±m:
app.UseExceptionHandler("/Home/Error");
Hatalar olduÄŸunda kullanÄ±cÄ± /Error sayfasÄ±na yÃ¶nlendirilir.
Ãœretim ortamÄ±nda (production) Ã¶nerilir.

GeliÅŸtirme ortamÄ± iÃ§in:
if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
Bu, detaylÄ± hata mesajlarÄ± ve stack trace gÃ¶sterir (debug iÃ§in yararlÄ±dÄ±r).

2. Kimlik DoÄŸrulama (Authentication)
AmaÃ§: KullanÄ±cÄ±nÄ±n kimliÄŸini doÄŸrulamak (giriÅŸ yapÄ±p yapmadÄ±ÄŸÄ±nÄ± kontrol etmek).

KullanÄ±m:
app.UseAuthentication();
KullanÄ±cÄ± profili veya ayarlarÄ± gibi gÃ¼venli alanlara eriÅŸimi kontrol eder.

3. Yetkilendirme (Authorization)
AmaÃ§: GiriÅŸ yapmÄ±ÅŸ kullanÄ±cÄ±larÄ±n hangi kaynaklara eriÅŸebileceÄŸini belirlemek.

KullanÄ±m:
app.UseAuthorization();
âš ï¸ Yetkilendirme kimlik doÄŸrulamadan sonra Ã§alÄ±ÅŸmalÄ±dÄ±r.

4. Loglama (Http Logging)
AmaÃ§: Her isteÄŸin detaylarÄ±nÄ±, hata mesajlarÄ±nÄ± ve kullanÄ±cÄ± aktivitelerini kaydetmek.

KullanÄ±m:
app.UseHttpLogging();
builder.Services.AddHttpLogging(logging => { });
AyrÄ±ca appsettings.json dosyasÄ±na ÅŸu satÄ±r eklenmelidir:

"Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware": "Information"
BÃ¶ylece her istek konsolda gÃ¶rÃ¼nÃ¼r.

ğŸ§  Genel BakÄ±ÅŸ
ASP.NET Coreâ€™un bu yerleÅŸik middleware bileÅŸenleri:
Uygulama hatalarÄ±nÄ± yÃ¶netir (UseExceptionHandler)
KullanÄ±cÄ± kimliÄŸini kontrol eder (UseAuthentication)
EriÅŸim izinlerini sÄ±nÄ±rlar (UseAuthorization)
OlaylarÄ± ve hatalarÄ± kaydeder (UseHttpLogging)
Bu bileÅŸenler birlikte Ã§alÄ±ÅŸarak uygulamanÄ±n gÃ¼venli, istikrarlÄ± ve kolay yÃ¶netilebilir olmasÄ±nÄ± saÄŸlar.

Kodun Ä°ncelemesi
app.Use(async (context, next) =>
{
    Console.WriteLine(context.Request.Method);
    Console.WriteLine(context.Request.Path);
    await next.Invoke();
    Console.WriteLine(context.Response.StatusCode);
});
ğŸ§± Kod Ne Yapar?
Bu kod bir anonim middleware bileÅŸeni (inline middleware) tanÄ±mlar. Åimdi adÄ±m adÄ±m aÃ§Ä±klayalÄ±m:

ğŸŸ¢ context.Request.Method
Gelen HTTP isteÄŸinin yÃ¶ntemini (GET, POST, PUT, DELETE...) yazdÄ±rÄ±r.
Ã–rnek Ã§Ä±ktÄ±: GET

ğŸŸ¢ context.Request.Path
Ä°steÄŸin hangi URL yoluna geldiÄŸini gÃ¶sterir.
Ã–rnek Ã§Ä±ktÄ±: /products/details

ğŸ” await next.Invoke();
Middleware zincirinde bir sonraki bileÅŸene geÃ§meyi saÄŸlar.
Bu satÄ±r Ã§alÄ±ÅŸmazsa, istek aÅŸaÄŸÄ± doÄŸru devam etmez, yani pipeline burada durur.

ğŸ”´ context.Response.StatusCode
YanÄ±t Ã¼retildikten sonra, sunucunun verdiÄŸi HTTP durum kodunu gÃ¶sterir.
Ã–rnek Ã§Ä±ktÄ±: 200, 404, 500

ğŸ§  Bu Middleware Ne Ä°ÅŸe Yarar?
Bu middleware:
Her HTTP isteÄŸi geldiÄŸinde, terminalde/logda isteÄŸin detaylarÄ±nÄ± yazar.
Uygulama bittikten sonra dÃ¶nen HTTP cevabÄ±nÄ± da gÃ¶sterir.
Ã–zellikle debug, geliÅŸtirme ve loglama aÅŸamalarÄ±nda Ã§ok faydalÄ±dÄ±r.

ğŸ“Œ Nerede KullanÄ±lÄ±r?
Program.cs veya Startup.cs iÃ§indeki middleware pipelineâ€™da genellikle en Ã¼st sÄ±ralarda kullanÄ±lÄ±r.
Ã–rneÄŸin hata ayÄ±klarken hangi endpointâ€™e hangi metodla eriÅŸilmiÅŸ ve hangi durum kodu dÃ¶nmÃ¼ÅŸ kolayca takip edilebilir.

âœ… Ã–rnek Ã‡Ä±ktÄ±
GET
/products/3
200

app.Use(async (context, next) =>
{
    var startTime = DateTime.Now;
    Console.WriteLine($"Request started at: {startTime}");
    await next.Invoke();
    var endTime = DateTime.Now;
    Console.WriteLine($"Request ended at: {endTime}");
    Console.WriteLine($"Request duration: {endTime - startTime}");
});
      Ã–rnek Ã‡Ä±ktÄ±
GET
/blogs
Request started at: 6.08.2025 12:00:59
Request ended at: 6.08.2025 12:00:59
Request duration: 00:00:00.0377239
200
POST
/blogs
Request started at: 6.08.2025 12:01:24
Request ended at: 6.08.2025 12:01:24
Request duration: 00:00:00.0158829
201
GET
/blogs
Request started at: 6.08.2025 12:01:31
Request ended at: 6.08.2025 12:01:31
Request duration: 00:00:00.0004909
200
GET
/blogs/1
Request started at: 6.08.2025 12:01:40
Request ended at: 6.08.2025 12:01:40
Request duration: 00:00:00.0014303
200


Ã–zel Middleware (Custom Middleware)
ğŸ§© GiriÅŸ
Bu rehber, ASP.NET Coreâ€™da Ã¶zel middleware (custom middleware) oluÅŸturmayÄ± ve uygulamayÄ± anlatÄ±r. Ele alÄ±nan Ã¶rnekler ÅŸunlardÄ±r:
Ä°stek loglama
YanÄ±t sÃ¼resini Ã¶lÃ§me
API anahtarÄ± (API key) doÄŸrulama

ğŸ“Œ Temel Noktalar
âœ… Middleware Temelleri
Middleware, ASP.NET Core uygulamalarÄ±nda gelen HTTP isteklerini iÅŸleyen iÅŸlem hattÄ±nÄ±n (pipeline) merkezinde yer alÄ±r.
app.Use() fonksiyonu ile Ã¶zel middleware tanÄ±mlanabilir.
Bu fonksiyon bir request delegate (istek temsilcisi) belirler; bu temsilci, isteÄŸi sÄ±rasÄ±yla iÅŸler.

ğŸ› ï¸ Ã–zel Middleware Ã–rnekleri
1. Loglama Middlewareâ€™i
Gelen isteÄŸin yolunu ve dÃ¶nen yanÄ±tÄ±n durum kodunu yazdÄ±rÄ±r.
Console.WriteLine ile istekten Ã¶nce ve sonra log alÄ±nÄ±r.

2. Zamanlama Middlewareâ€™i
Her isteÄŸin ne kadar sÃ¼rdÃ¼ÄŸÃ¼nÃ¼ Ã¶lÃ§er.
DateTime.Now ile iÅŸlem baÅŸlangÄ±Ã§ zamanÄ± alÄ±nÄ±r.
await next() sonrasÄ± geÃ§en sÃ¼re hesaplanÄ±r ve yazdÄ±rÄ±lÄ±r.

3. KoÅŸullu Middleware â€“ UseWhen()
Middlewareâ€™in sadece belli ÅŸartlarda Ã§alÄ±ÅŸmasÄ± saÄŸlanÄ±r.
Ã–rneÄŸin: GET dÄ±ÅŸÄ±ndaki istekler iÃ§in Ã¶zel iÅŸlem yapÄ±lmasÄ±.

4. API AnahtarÄ± ile EriÅŸim KontrolÃ¼
Belirli bir API Key deÄŸeri olan istekler kabul edilir.
GeÃ§ersiz veya eksik API Key olanlara 401 Unauthorized yanÄ±tÄ± dÃ¶ner.
GÃ¼venlik amaÃ§lÄ± kullanÄ±labilir.

ğŸ§  SonuÃ§
Bu Ã¶zel middleware Ã¶rnekleri, ASP.NET Coreâ€™un yeteneklerini geliÅŸtirmenizi saÄŸlar:
Ä°zleme (logging)
Performans Ã¶lÃ§Ã¼mÃ¼ (timing)
EriÅŸim kontrolÃ¼ (security)
Bu sayede daha gÃ¼venli, izlenebilir ve Ã¶zelleÅŸtirilebilir web uygulamalarÄ± geliÅŸtirebilirsiniz.

âœ… ASP.NET Core â€“ Custom Middleware (Ã–zel Ara YazÄ±lÄ±m) Ã–ÄŸretici Ã–zeti
ğŸ“Œ Neden Ã–zel Middleware KullanÄ±lÄ±r?
.NET Core birÃ§ok yerleÅŸik middleware sunar; ancak uygulamaya Ã¶zel ihtiyaÃ§lar ortaya Ã§Ä±ktÄ±ÄŸÄ±nda, geliÅŸtiricilerin kendi middleware bileÅŸenlerini yazmasÄ± gerekir. Bu sayede isteklerin nasÄ±l iÅŸlendiÄŸini detaylÄ±ca kontrol edebiliriz.

âš™ï¸ Middleware NasÄ±l Ã‡alÄ±ÅŸÄ±r?
Middlewareâ€™ler sÄ±rayla Ã§alÄ±ÅŸÄ±r (pipeline).
Her biri bir HTTP isteÄŸini iÅŸler ve bir sonraki middlewareâ€™e aktarÄ±r (next.Invoke() ile).
Kodun next.Invoke() Ã¶ncesi, istekten Ã¶nce Ã§alÄ±ÅŸÄ±r.
Kodun next.Invoke() sonrasÄ±, yanÄ±t geri dÃ¶nerken Ã§alÄ±ÅŸÄ±r.
EÄŸer next.Invoke() Ã§aÄŸrÄ±lmazsa, o middleware "terminal" olur ve zincir orada kesilir.

ğŸ› ï¸ Uygulamada 3 Ã–zel Middleware Ã–rneÄŸi
1. Ä°stek ve YanÄ±t Loglama Middlewareâ€™i
app.Use(async (context, next) =>
{
    Console.WriteLine(context.Request.Path);          // Ä°stek yolu
    await next.Invoke();                              // Bir sonraki middleware'e geÃ§
    Console.WriteLine(context.Response.StatusCode);   // YanÄ±t durumu
});
ğŸ’¡ Ne yapar?
Her istek geldiÄŸinde yol (path) bilgisini loglar.
YanÄ±t dÃ¶nerken HTTP durum kodunu loglar.
GeliÅŸtirme sÄ±rasÄ±nda basit loglama iÃ§in Ã§ok kullanÄ±ÅŸlÄ±dÄ±r.

2. Ä°stek SÃ¼resi Ã–lÃ§en Middleware
app.Use(async (context, next) =>
{
    var startTime = DateTime.Now;
    Console.WriteLine($"Request started at: {startTime}");
    await next.Invoke();
    var endTime = DateTime.Now;
    Console.WriteLine($"Request ended at: {endTime}");
    Console.WriteLine($"Request duration: {endTime - startTime}");
});
ğŸ’¡ Ne yapar?

Ä°stek iÅŸlenmeden Ã¶nce zamanÄ± alÄ±r.
Ä°ÅŸlem tamamlandÄ±ktan sonra geÃ§en sÃ¼reyi hesaplar.
Performans analizi iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.
ğŸ“Œ SÄ±ralama Ã¶nemli: Bu middlewareâ€™i loglama middlewareâ€™inin Ã¼stÃ¼ne koyarsan, tÃ¼m iÅŸlemlerin sÃ¼resini Ã¶lÃ§ebilirsin.

3. API AnahtarÄ± ile EriÅŸim KontrolÃ¼ (UseWhen ile KoÅŸullu Middleware)
//Postman iÃ§inde Headers kÄ±smÄ±na X-Api-Key: thisIsABadPassword yazarsak, bu middleware Ã§alÄ±ÅŸacak ve istek devam edecek.
app.UseWhen(
    context => context.Request.Method != "GET",
    appBuilder => appBuilder.Use(async (context, next) =>
    {
        var extractedPassword = context.Request.Headers["X-Api-Key"];
        if (extractedPassword == "thisIsABadPassword")
        {
            await next.Invoke();
        }
        else
        {
            context.Response.StatusCode = 401; // Unauthorized
            await context.Response.WriteAsync("Unauthorized access");
        }
    })
);
ğŸ’¡ Ne yapar?
Sadece GET olmayan isteklerde Ã§alÄ±ÅŸÄ±r (POST, PUT, DELETE).
Headerâ€™da gÃ¶nderilen xAPIKey kontrol edilir.
Anahtar doÄŸruysa istek devam eder.
YanlÄ±ÅŸsa 401 Unauthorized dÃ¶ner.

ğŸ›‘ Not: API anahtarÄ± doÄŸrudan kodda tutulmamalÄ±. GerÃ§ek uygulamalarda Ã§evresel deÄŸiÅŸkenler (environment variables) kullanÄ±lÄ±r.

ğŸ“š Ekstra Bilgiler
app.Use(...): Genel middleware tanÄ±mÄ±
app.UseWhen(...): KoÅŸullu middleware tanÄ±mÄ±
context: HTTP isteÄŸi ve yanÄ±tÄ±na ait bilgileri iÃ§erir
next: Sonraki middlewareâ€™i temsil eder

ğŸ§  SonuÃ§ ve Tavsiyeler
Bu Ã¶rneklerle, Ã¶zel middleware yazarak:
Basit loglama ve izleme iÅŸlemleri yapabilirsin
Performans sÃ¼relerini analiz edebilirsin
GÃ¼venlik kontrolleri ekleyebilirsin (Ã¶rneÄŸin API key doÄŸrulama)

ğŸ¯ Tavsiye:
Kodlarla deneme yap, middleware sÄ±rasÄ±nÄ± deÄŸiÅŸtir, yeni kontroller ekle. GerÃ§ek uygulama yapÄ±sÄ± ve davranÄ±ÅŸÄ±nÄ± daha iyi anlamanÄ± saÄŸlar.

BÃ¼tÃ¼n Kod:
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var blogs = new List<Blog>
{
    new Blog { Title = "First Blog", Body = "This is the body of the first blog." },
    new Blog { Title = "Second Blog", Body = "This is the body of the second blog." }
};

app.Use(async (context, next) =>
{
    Console.WriteLine(context.Request.Method);
    Console.WriteLine(context.Request.Path);
    await next.Invoke();
    Console.WriteLine(context.Response.StatusCode);
});

app.Use(async (context, next) =>
{
    var startTime = DateTime.Now;
    Console.WriteLine($"Request started at: {startTime}");
    await next.Invoke();
    var endTime = DateTime.Now;
    Console.WriteLine($"Request ended at: {endTime}");
    Console.WriteLine($"Request duration: {endTime - startTime}");
});

app.Use(async (context, next) =>
{
    if (context.Request.Method == "GET")
    {
        Console.WriteLine("GET request detected.");
    }
    else if (context.Request.Method == "POST")
    {
        Console.WriteLine("POST request detected.");
    }
    else if (context.Request.Method == "PUT")
    {
        Console.WriteLine("PUT request detected.");
    }
    else if (context.Request.Method == "DELETE")
    {
        Console.WriteLine("DELETE request detected.");
    }
    else
    {
        Console.WriteLine("Non-GET request detected.");
    }
    await next.Invoke();
});

//app.Use(async (context, next) =>
//{
//    switch(context.Request.Method)
//    {
//        case "GET":
//            Console.WriteLine("Processing GET request.");
//            break;
//        case "POST":
//            Console.WriteLine("Processing POST request.");
//            break;
//        case "PUT":
//            Console.WriteLine("Processing PUT request.");
//            break;
//        case "DELETE":
//            Console.WriteLine("Processing DELETE request.");
//            break;
//        default:
//            Console.WriteLine("Processing other request.");
//            break;
//    }
//    await next.Invoke();
//});
//Postman iÃ§inde Headers kÄ±smÄ±na X-Api-Key: thisIsABadPassword yazarsak, bu middleware Ã§alÄ±ÅŸacak ve istek devam edecek.
app.UseWhen(
    context => context.Request.Method != "GET",
    appBuilder => appBuilder.Use(async (context, next) =>
    {
        var extractedPassword = context.Request.Headers["X-Api-Key"];
        if (extractedPassword == "thisIsABadPassword")
        {
            await next.Invoke();
        }
        else
        {
            context.Response.StatusCode = 401; // Unauthorized
            await context.Response.WriteAsync("Unauthorized access");
        }
    })
);

//Postman iÃ§inde Headers kÄ±smÄ±na X-Api-Key: GetRequestPassword yazarsak, bu middleware Ã§alÄ±ÅŸacak ve istek devam edecek.
app.UseWhen(context => context.Request.Method == "GET",
    appBuilder => appBuilder.Use(async (context, next) =>
    {
        var extractedPassword = context.Request.Headers["X-Api-Key"];
        if (extractedPassword == "GetRequestPassword")
        {
            await next.Invoke();
        }
        else
        {
            context.Response.StatusCode = 401; // Unauthorized
            await context.Response.WriteAsync("Unauthorized access");
        }
    })
);


app.MapGet("/", () => "Hello World!");


app.MapGet("/blogs", () =>
{
    return blogs;
});

//Read specific blogs
app.MapGet("/blogs/{id}", (int id) =>
{
    if (id >= 1 && id <= blogs.Count)
    {
        return Results.Ok(blogs[id - 1]);
    }
    else
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
});

//Create a new blog
app.MapPost("/blogs", (Blog blog) => {
    blogs.Add(blog);
    return Results.Created($"/blogs/{blogs.Count - 1}", blog);
});

//Delete a blog
app.MapDelete("/blogs/{id}", (int id) => {
    if (id >= 1 && id <= blogs.Count)
    {
        blogs.RemoveAt(id - 1);
        return Results.NoContent(); //204 No Content? HTTP 204 durumu, bir isteÄŸin (genelde PUT, DELETE) baÅŸarÄ±yla iÅŸlendiÄŸini fakat sunucunun dÃ¶ndÃ¼recek iÃ§eriÄŸi olmadÄ±ÄŸÄ±nÄ± belirtir.
    }
    else
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
});

//Update a blog
app.MapPut("/blogs/{id}", (int id, Blog blog) =>
{
    if (id >= 1 && id <= blogs.Count)
    {
        blogs[id - 1] = blog; // Update the blog at the specified index
        return Results.Ok($"Updated: {blog}");
    }
    else
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
});

app.Run();

public class Blog
{
    public required string Title { get; set; }
    public required string Body { get; set; }
}
