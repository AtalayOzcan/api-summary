Serialization (SerileÅŸtirme), bir nesnenin bellekteki halini dÃ¼z bir veri formatÄ±na (Ã¶rneÄŸin JSON, XML veya ikili bir format) Ã§evirme iÅŸlemidir. Bu iÅŸlem sayesinde bir nesne:
Dosyaya yazÄ±labilir,
AÄŸ Ã¼zerinden gÃ¶nderilebilir,
VeritabanÄ±na kaydedilebilir,
BaÅŸka sistemlere taÅŸÄ±nabilir hale gelir.

Serialization Nedir?
TanÄ±m: Serialization, bir nesnenin durumunun (property deÄŸerlerinin) dÃ¼z bir formatta temsil edilmesidir. BÃ¶ylece bu nesne baÅŸka bir ortama taÅŸÄ±nabilir veya kalÄ±cÄ± hale getirilebilir.

AmacÄ± Nedir?
Serializationâ€™Ä±n temel amacÄ±, verinin taÅŸÄ±nabilir ve kalÄ±cÄ± hale getirilmesidir. Ã–zellikle ÅŸu durumlarda kullanÄ±lÄ±r:
Dosyaya yazmak (file storage): Nesnenin son halini bir .json, .xml veya .bin dosyasÄ±na kaydetmek.
Veri transferi (networking): Bir nesneyi istemci-sunucu arasÄ±nda gÃ¶ndermek (Ã¶rneÄŸin Web API'lerde JSON formatÄ±nda veri).
VeritabanÄ±na kayÄ±t: Nesneyi JSON formatÄ±nda bir sÃ¼tunda saklamak.
Cache sistemleri: Bir nesneyi serialize edip RAMâ€™de veya disk cacheâ€™te saklamak.
Uygulama durumunu korumak: Program kapanÄ±p aÃ§Ä±ldÄ±ÄŸÄ±nda kaldÄ±ÄŸÄ± yerden devam edebilmek iÃ§in.

NiÃ§in KullanÄ±lÄ±r?
Serialization sayesinde:
Veriler ortamlar arasÄ± geÃ§iÅŸ yapabilir (Ã¶rneÄŸin bir uygulamadan baÅŸka bir uygulamaya veri aktarÄ±mÄ±).
Nesneler diskte saklanabilir, daha sonra tekrar belleÄŸe alÄ±nabilir (bu iÅŸleme deserialization denir).
FarklÄ± platformlar arasÄ±nda dil baÄŸÄ±msÄ±z iletiÅŸim saÄŸlanÄ±r (Ã¶rneÄŸin: bir C# backendâ€™ten JSON olarak veri gÃ¶nderilip, bir JavaScript frontendâ€™te okunabilir).

C# Ã–RNEÄÄ° SERIALIZATION
using System.Text.Json;

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

// Serialization
var person = new Person { Name = "Atalay", Age = 24 };
string json = JsonSerializer.Serialize(person);

// Deserialization
Person newPerson = JsonSerializer.Deserialize<Person>(json);

KULLANILAN FORMATLAR
| Format | AÃ§Ä±klama                                                   |
| ------ | ---------------------------------------------------------- |
| JSON   | Web API'lerde en yaygÄ±n kullanÄ±lan format                  |
| XML    | Eski sistemlerde hÃ¢lÃ¢ yaygÄ±n                               |
| Binary | Daha kÃ¼Ã§Ã¼k boyut, daha hÄ±zlÄ± ama insan tarafÄ±ndan okunamaz |
| CSV    | Basit veri yapÄ±larÄ±nda                                     |

Deserialization Nedir?
Deserialization (SerileÅŸtirilmiÅŸ veriyi nesneye dÃ¶nÃ¼ÅŸtÃ¼rme), dÃ¼z bir veri formatÄ±nda (Ã¶rneÄŸin JSON, XML, Binary) saklanan/verilen bilgiyi orijinal nesne haline geri dÃ¶ndÃ¼rme iÅŸlemidir.

Yani:
Serialization: Nesne â†’ JSON/XML/Binary
Deserialization: JSON/XML/Binary â†’ Nesne

AmacÄ± Nedir?
AmaÃ§, baÅŸka yerden gelen, saklanan ya da taÅŸÄ±nan veriyi tekrar programda Ã§alÄ±ÅŸabilecek bir nesne haline getirmektir.
Yani:
ğŸ§¾ "Veri olarak gelen ÅŸeyi"
ğŸ”§ "KullanÄ±labilir bir yapÄ±ya"
dÃ¶nÃ¼ÅŸtÃ¼rmektir.

â—ï¸Neden KullanÄ±lÄ±r?
Serialization bir ara formattÄ±r; sadece saklama veya gÃ¶nderme iÃ§in iÅŸe yarar.
Ama bu veriyle iÅŸlem yapabilmek iÃ§in onu tekrar canlÄ± bir nesneye dÃ¶nÃ¼ÅŸtÃ¼rmen gerekir. Ä°ÅŸte bu noktada deserialization devreye girer.

Neden YaratÄ±ldÄ±?
Ã‡Ã¼nkÃ¼:
Bilgi taÅŸÄ±nÄ±rken sadece dÃ¼z metin olabilir (Ã¶rneÄŸin JSON).
Ama program bu metinle Ã§alÄ±ÅŸamaz. Nesne gerekir.
O yÃ¼zden bu dÃ¼z metni tekrar belleÄŸe, anlamlÄ± yapÄ±ya otomatik olarak Ã§evirmek gerekiyor.

C# JSON Ã–rneÄŸi
1. JSON Veri:
{
  "Name": "Atalay",
  "Age": 24
}
2. C# Nesne:
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}
3. Deserialization:
string json = File.ReadAllText("person.json");
Person p = JsonSerializer.Deserialize<Person>(json);
Console.WriteLine($"Ad: {p.Name}, YaÅŸ: {p.Age}");

NERELERDE KULLANILIR
Nerelerde GÃ¶rÃ¼lÃ¼r?
Web APIâ€™den gelen JSON veriyi nesneye Ã§evirme.
Dosyaya kaydedilmiÅŸ nesneleri tekrar aÃ§ma.
Networkâ€™ten gelen mesajlarÄ± nesneye dÃ¶nÃ¼ÅŸtÃ¼rme.
Yapay zeka veya oyun verilerini geri yÃ¼kleme.
Otomatik form doldurma (Ã¶nceki bilgilerin nesneye aktarÄ±mÄ±).

Ã–ZETLE
| SÃ¼reÃ§               | AmaÃ§                                                 |
| ------------------- | ---------------------------------------------------- |
| Serialization       | Nesneyi taÅŸÄ±nabilir/saklanabilir hale getirmek       |
| **Deserialization** | **Veriyi programda iÅŸlenebilir nesneye dÃ¶nÃ¼ÅŸtÃ¼rmek** |


SERIALIZATION ORNEGI

using System.Text.Json;
using System.Xml.Serialization;

var builder = WebApplication.CreateBuilder(args);

builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase; //GENEL AUTO VE JSON OLANLAR Ä°Ã‡Ä°N YAZIM STÄ°LÄ°.
});

var app = builder.Build();

var samplePerson = new Person { UserName = "Alice", UserAge = 30 };

app.MapGet("/", () => "Hello World!");

app.MapGet("/manual-json", () =>
{
    var jsonString = JsonSerializer.Serialize(samplePerson);
    return TypedResults.Text(jsonString, "application/json");
});

app.MapGet("/custom-serializer", () =>
{
    var options = new JsonSerializerOptions
    {
        PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower
    };
    var customJsonString = JsonSerializer.Serialize(samplePerson, options);
    return TypedResults.Text(customJsonString, "application/json");
});

app.MapGet("/json", () =>{
   return TypedResults.Json(samplePerson);
});

app.MapGet("/auto", () =>
{
    return samplePerson;
});

app.MapGet("/xml", () =>
{
    var xmlSerializer = new XmlSerializer(typeof(Person));
    var stringWriter = new StringWriter();
    xmlSerializer.Serialize(stringWriter, samplePerson);
    var xmlOutput = stringWriter.ToString();
    return TypedResults.Text(xmlOutput, "application/xml");
});


app.Run();
    
public class Person
{
    public string UserName { get; set; }
    public int UserAge { get; set; }
}

1)builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase; //GENEL AUTO VE JSON OLANLAR Ä°Ã‡Ä°N YAZIM STÄ°LÄ°.
});

ğŸ‘‰ Ne yapÄ±yor?
JSON verilerini auto ÅŸekilde dÃ¼zenlerken bir yazÄ±m dÃ¼zeni saÄŸlÄ±yor.

2) app.MapGet("/manual-json", ...)
var jsonString = JsonSerializer.Serialize(samplePerson);
return TypedResults.Text(jsonString, "application/json");

ğŸ‘‰ Ne yapÄ±yor?
samplePerson nesnesini elle JSON formatÄ±na Ã§eviriyor (Serialize).
Sonra bu JSON stringâ€™i, Text olarak geri dÃ¶ndÃ¼rÃ¼yor.
application/json content type'Ä± elle veriliyor.
ğŸ§  Bu yÃ¶ntem, elle serialization yapmaktÄ±r.

3) app.MapGet("/custom-serializer", ...)
var options = new JsonSerializerOptions
{
    PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower
};
ğŸ‘‰ Ne yapÄ±yor?
JSON iÃ§indeki property adlarÄ±nÄ± snake_case yapÄ±yor.
Ã–rneÄŸin FirstName â†’ first_name gibi.
Daha Ã¶zelleÅŸtirilmiÅŸ bir JSON istiyorsan bu seÃ§eneklerle oynarsÄ±n.

4) app.MapGet("/json", ...) -->>>auto ile dÃ¶nen veri aslÄ±nda TypedResults.Json(...) ile aynÄ±dÄ±r. Sadece sen yazmazsÄ±n, framework senin yerine yapar. Performans farkÄ± da yok denecek kadar azdÄ±r.
return TypedResults.Json(samplePerson);

ğŸ‘‰ Ne yapÄ±yor?
samplePerson nesnesini otomatik olarak JSON formatÄ±nda dÃ¶ndÃ¼rÃ¼yor.
application/json content type'Ä± otomatik.
System.Text.Json kullanÄ±yor.
Daha kÄ±sa ve temiz bir yÃ¶ntem!

5) app.MapGet("/auto", ...)-->>>auto ile dÃ¶nen veri aslÄ±nda TypedResults.Json(...) ile aynÄ±dÄ±r. Sadece sen yazmazsÄ±n, framework senin yerine yapar. Performans farkÄ± da yok denecek kadar azdÄ±r.
return samplePerson;

En sade yÃ¶ntem! Peki burada ne oluyor?
Minimal API'de ASP.NET Core, dÃ¶nen deÄŸerin tÃ¼rÃ¼ne bakÄ±yor.
Geriye bir class dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼ gÃ¶rÃ¼nce, otomatik olarak JSON'a serialize ediyor.
Yani aslÄ±nda JsonSerializer.Serialize() iÅŸlemini arkada kendi yapÄ±yor.
AyrÄ±ca Content-Type: application/json baÅŸlÄ±ÄŸÄ±nÄ± da otomatik ayarlÄ±yor.

ğŸ’¡ SonuÃ§:
Sen hiÃ§bir ÅŸey yazmadan ASP.NET Core diyor ki:
â€œBu bir nesne, ben bunu JSON yapÄ±p yollayayÄ±m!â€

6) app.MapGet("/xml", ...)

Ne yapÄ±yor?
samplePerson nesnesini XML formatÄ±na Ã§eviriyor.
JSON deÄŸil, eski sistemlerle konuÅŸmak istiyorsan veya XML isteyen bir uygulamaya veri gÃ¶nderiyorsan kullanÄ±lÄ±r.

Ã–zetle: Hangi Yol Ne Zaman?
| Endpoint             | Ne YapÄ±yor?                     | Ne Zaman KullanÄ±lÄ±r?                         |
| -------------------- | ------------------------------- | -------------------------------------------- |
| `/manual-json`       | Elle JSONâ€™a Ã§eviriyor           | Ã–zelleÅŸtirilmiÅŸ Ã§Ä±ktÄ±larda                   |
| `/custom-serializer` | snake\_case gibi ayarlarla JSON | API dÄ±ÅŸa aÃ§Ä±k ve format kontrolÃ¼ isteniyorsa |
| `/json`              | JSON olarak dÃ¶ner (kÄ±sa yol)    | Ã‡oÄŸu API iÃ§in yeterli                        |
| âœ… `/auto`            | Her ÅŸeyi **otomatik** yapar     | En sade yol, hÄ±zlÄ± geliÅŸtirme iÃ§in ideal   |
| `/xml`               | XML Ã§Ä±ktÄ±sÄ± Ã¼retir              | XML kullanan sistemlerle Ã§alÄ±ÅŸÄ±rken          |

.NET'te SerileÅŸtirme (Serialization) UygulamasÄ±
ğŸ”§ Manuel JSON SerileÅŸtirme
JsonSerializer.Serialize yÃ¶ntemi kullanÄ±larak geliÅŸtiriciler, Ã¶zel gereksinimler (Ã¶rneÄŸin, Ã¶zel adlandÄ±rma kurallarÄ±) iÃ§in JSON serileÅŸtirmesini manuel olarak kontrol edebilirler.
Bu iÅŸlem, JsonSerializerOptions aracÄ±lÄ±ÄŸÄ±yla gerÃ§ekleÅŸtirilir.

âš™ï¸ Otomatik JSON SerileÅŸtirme
ASP.NET Core ile birlikte, sadece bir nesne dÃ¶ndÃ¼rerek JSON serileÅŸtirme otomatik hale getirilebilir.
Framework, bu nesneyi varsayÄ±lan olarak JSON formatÄ±na Ã§evirir. Bu yÃ¶ntem, aÃ§Ä±kÃ§a serileÅŸtirme kodu yazma ihtiyacÄ±nÄ± ortadan kaldÄ±rarak geliÅŸtirme sÃ¼recini sadeleÅŸtirir.

ğŸ› ï¸ Ã–zel SerileÅŸtirme AyarlarÄ±
Ã–zel ayarlar, geliÅŸtiricilerin uygulama genelinde Ã¶zellik (property) adlandÄ±rma kurallarÄ±nÄ± standartlaÅŸtÄ±rmasÄ±nÄ± saÄŸlar.
Ã–rneÄŸin, ASP.NET Core'da global bir property adlandÄ±rma politikasÄ± belirlemek, birden fazla route (yol) arasÄ±nda tutarlÄ±lÄ±ÄŸÄ± korur. AynÄ± zamanda, gerektiÄŸinde route'a Ã¶zel ayarlarla esneklik saÄŸlanabilir.

ğŸ“ XmlSerializer ile XML SerileÅŸtirme
.NET'te XML serileÅŸtirme, XmlSerializer sÄ±nÄ±fÄ± kullanÄ±larak gerÃ§ekleÅŸtirilir. Bu sÄ±nÄ±f, nesne verilerini XML formatÄ±nda yakalar.
JSON serileÅŸtirmeye kÄ±yasla daha karmaÅŸÄ±k olsa da, XML serileÅŸtirme verinin biÃ§imlendirilmesi Ã¼zerinde daha fazla kontrol saÄŸlar. Bu da XML gerektiren sistemlerle uyumluluÄŸu garanti eder.


# ğŸ“˜ .NETâ€™te Deserialization â€“ GiriÅŸ, Kodlar ve Ã–zet Notlar

ğŸ“… Tarih: 2025-08-04

## ğŸ¯ GiriÅŸ: Deserialization Nedir?

Deserialization, saklanan veya iletilen verilerin tekrar program iÃ§inde kullanÄ±labilir nesnelere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesidir. Ã–zellikle:

- KullanÄ±cÄ± tercihleri,
- Ayarlar,
- API'den gelen veri gibi

kalÄ±cÄ± verilerin geri yÃ¼klenmesi iÃ§in kritik Ã¶nemdedir.

---

## ğŸ” .NETâ€™te Deserialization SÃ¼reci

- **Serialization**: Nesneleri JSON, XML, binary gibi biÃ§imlere Ã§evirme iÅŸlemidir.
- **Deserialization**: Bu biÃ§imlerden tekrar nesne haline getirme iÅŸlemidir.

---

## ğŸ”– YaygÄ±n Formatlar

| Format | AÃ§Ä±klama |
|--------|----------|
| JSON   | Web iÃ§in idealdir, okunabilir, esnek ve yaygÄ±n |
| XML    | HiyerarÅŸik veri yapÄ±larÄ± iÃ§in kullanÄ±lÄ±r, yapÄ±landÄ±rma dosyalarÄ±nda tercih edilir |
| Binary | BÃ¼yÃ¼k verilerde hÄ±zlÄ±dÄ±r, ancak gÃ¼venlik aÃ§Ä±sÄ±ndan dikkat gerektirir |

---

## ğŸ› ï¸ Pratik Uygulama YÃ¶ntemleri

- JSON deserialization iÃ§in System.Text.Json veya Newtonsoft.Json kullanÄ±lÄ±r.
- HttpContext.Request.ReadFromJsonAsync<T>() ile manuel deserialization yapÄ±labilir.
- JsonSerializerOptions ile Ã¶zelleÅŸtirme mÃ¼mkÃ¼ndÃ¼r:
  - PropertyNamingPolicy
  - UnmappedMemberHandling
  - PropertyNameCaseInsensitive

---

## âœ… ASP.NET Core Empty Template â€“ Ã–rnek Kodlar

Program.cs iÃ§inde deserialization iÃ§in Ã¶rnek endpointâ€™ler:

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.MapPost("/auto", (Person personFromClient) => {
    return TypedResults.Ok(personFromClient);
});

app.MapPost("/json", async (HttpContext context) =>
{
    var person = await context.Request.ReadFromJsonAsync<Person>();
    return TypedResults.Ok(person);
});

app.MapPost("/custom", async (HttpContext context) =>
{
    var options = new JsonSerializerOptions
    {
        UnmappedMemberHandling = JsonUnmappedMemberHandling.Disallow
    };
    var person = await context.Request.ReadFromJsonAsync<Person>(options);
    return TypedResults.Ok(person);
});

app.Run();

public class Person
{
    required public string UserName { get; set; }
    public int? UserAge { get; set; }
}
```

---

## ğŸ“¤ Test JSON Ã–rnekleri

GeÃ§erli:
{
  "userName": "Mert",
  "userAge": 25
}

HatalÄ± (/custom endpoint'inde):
{
  "userName": "Mert",
  "userAge": 25,
  "extra": "not allowed"
}

---

## âš ï¸ Dikkat Edilmesi Gerekenler

1. Veri DoÄŸrulama
- Eksik veya hatalÄ± veri geldiÄŸinde:
  - int? gibi nullable tiplerle Ã¶nlem alÄ±nabilir.
  - required keywordâ€™Ã¼ ile zorunlu alanlar belirlenebilir.

2. GÃ¼venlik
- Binary deserialization Ã¶zellikle tehlikelidir.
- JSON verisi dÄ±ÅŸ kaynaklÄ±ysa:
  - UnmappedMemberHandling.Disallow gibi sÄ±kÄ± kurallar kullanÄ±lmalÄ±.
  - Gelen veriler DTO ile izole edilmelidir.

---

## ğŸ” GeliÅŸtirme Ã–nerileri

- FluentValidation ile veri doÄŸrulama katmanÄ± ekle
- Results.Problem() ile anlamlÄ± hata mesajlarÄ± dÃ¶ndÃ¼r
- GiriÅŸ verisini loglama/middleware ile analiz et

---

## ğŸ§© SonuÃ§

.NET ortamÄ±nda deserialization:

- Verinin gÃ¼venli, esnek ve anlamlÄ± bir ÅŸekilde iÅŸlenmesini saÄŸlar.
- JSON, XML, Binary gibi farklÄ± veri formatlarÄ±na uyumludur.
- Web APIâ€™lerde model binding veya manuel deserialization ile kolaylÄ±kla uygulanabilir.
- GeliÅŸtirici, yapÄ±landÄ±rma ve gÃ¼venlik konularÄ±nda dikkatli davrandÄ±ÄŸÄ±nda, deserialization veri iÅŸleme altyapÄ±sÄ±nÄ±n temel yapÄ± taÅŸÄ± olur.
