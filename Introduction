API nedir, ne iÅŸe yarar?
API, farklÄ± yazÄ±lÄ±m uygulamalarÄ±nÄ±n veya sistemlerin birbirleriyle iletiÅŸim kurmasÄ±nÄ± saÄŸlayan bir arayÃ¼zdÃ¼r. Yani, bir programÄ±n baÅŸka bir programla "konuÅŸmasÄ±nÄ±" mÃ¼mkÃ¼n kÄ±lar.

Minimal API, ASP.NET Coreâ€™da, Controller sÄ±nÄ±flarÄ±, Startup.cs, IActionResult, routing attributes gibi yapÄ±lar olmadan doÄŸrudan Program.cs dosyasÄ±nda basit ve sade bir biÃ§imde HTTP endpointâ€™leri tanÄ±mlamana olanak tanÄ±yan bir yaklaÅŸÄ±mdÄ±r.
"Minimal kod, maksimum iÅŸ" felsefesiyle REST API'leri oluÅŸturmanÄ± saÄŸlar.

| Ã–zellik                               | AÃ§Ä±klama                                     |
| ------------------------------------- | -------------------------------------------- |
| ğŸ”¸ Basit yapÄ±                         | Sadece `Program.cs` yeterli                  |
| ğŸ”¸ HÄ±zlÄ± baÅŸlangÄ±Ã§                    | Controller, Startup, Service yapÄ±sÄ± gerekmez |
| ğŸ”¸ Performans odaklÄ±                  | Gereksiz abstraction yoktur, daha hÄ±zlÄ±dÄ±r   |
| ğŸ”¸ GeliÅŸtirici dostu                  | Az satÄ±rla Ã§ok iÅŸ yapÄ±lÄ±r                    |
| ğŸ”¸ Test ve kÃ¼Ã§Ã¼k servisler iÃ§in ideal | Mikro servis yapÄ±larÄ± iÃ§in uygundur          |

Ã–rnek MinimalApi
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "Hello World!");
app.MapGet("/hello", () => "Merhaba!");
app.MapGet("/square/{number}", (int number) => number * number);

app.Run();

| Klasik ASP.NET Core                   | Minimal API                    |
| ------------------------------------- | ------------------------------ |
| Controller sÄ±nÄ±flarÄ± gerekir          | Gerekmez                       |
| `[HttpGet]`, `[Route]` vs kullanÄ±lÄ±r  | `MapGet`, `MapPost` kullanÄ±lÄ±r |
| Startup.cs / ConfigureServices vardÄ±r | Gerekmez                       |
| Daha fazla boilerplate kod            | Daha az, sade yapÄ±             |



Basit Ã¶rnekle aÃ§Ä±klamak gerekirse:
Diyelim bir hava durumu uygulamasÄ± var. Bu uygulama, hava durumu verilerini dÄ±ÅŸarÄ±dan bir kaynaktan (mesela bir hava durumu servisi) almak ister.
API, bu uygulamanÄ±n dÄ±ÅŸ servisle iletiÅŸim kurmasÄ± iÃ§in belirlenmiÅŸ kurallar ve protokoller setidir.
Uygulama API aracÄ±lÄ±ÄŸÄ±yla servisden gÃ¼ncel hava durumu verisini ister, servis de uygun formatta yanÄ±t verir.

APIâ€™nin temel Ã¶zellikleri:
Veri alÄ±ÅŸveriÅŸi: Uygulamalar arasÄ± veri gÃ¶nderip alma iÅŸlemini kolaylaÅŸtÄ±rÄ±r.
Standart iletiÅŸim: Ä°ki sistemin nasÄ±l konuÅŸacaÄŸÄ±nÄ±, hangi verileri nasÄ±l isteyeceÄŸini ve cevaplayacaÄŸÄ±nÄ± belirler.
Soyutlama: API kullanÄ±cÄ±larÄ±, sistemin iÃ§ detaylarÄ±nÄ± bilmeden iÅŸlevleri kullanabilir.
Tekrarlanabilirlik: APIâ€™ler standart olduÄŸu iÃ§in birÃ§ok uygulama tarafÄ±ndan tekrar tekrar kullanÄ±labilir.

Web API Nedir?
Web API, farklÄ± uygulamalarÄ±n veya sistemlerin internet Ã¼zerinden HTTP protokolÃ¼ aracÄ±lÄ±ÄŸÄ±yla veri alÄ±ÅŸveriÅŸi yapmasÄ±nÄ± saÄŸlayan arayÃ¼zdÃ¼r.
HTTP: Web tarayÄ±cÄ±larÄ±nÄ±n ve sunucularÄ±n kullandÄ±ÄŸÄ± iletiÅŸim protokolÃ¼dÃ¼r. (GET, POST, PUT, DELETE gibi metotlarÄ± vardÄ±r.)
Web API, bu protokolÃ¼ kullanarak, bir uygulamanÄ±n baÅŸka bir uygulamaya veri gÃ¶ndermesini veya ondan veri almasÄ±nÄ± saÄŸlar.

Web APIâ€™nin Temel Ã–zellikleri:
Ä°nternet Ã¼zerinde Ã§alÄ±ÅŸÄ±r.
Genellikle REST veya SOAP gibi standart mimariler kullanÄ±r.
Veri formatÄ± olarak genellikle JSON veya XML kullanÄ±lÄ±r.
Platform baÄŸÄ±msÄ±zdÄ±r; farklÄ± programlama dilleri ve sistemler tarafÄ±ndan kullanÄ±labilir.

RESTâ€™in Temel KavramlarÄ±
Kaynak (Resource):
Ä°nternet Ã¼zerindeki her ÅŸey bir "kaynak" olarak dÃ¼ÅŸÃ¼nÃ¼lebilir. Ã–rneÄŸin; kullanÄ±cÄ±lar, Ã¼rÃ¼nler, mesajlar, sipariÅŸler birer kaynaktÄ±r.
Her kaynaÄŸÄ±n benzersiz bir URI (Uniform Resource Identifier) adresi vardÄ±r. Ã–rnek: https://api.example.com/users/123
HTTP MetodlarÄ±:
REST API, HTTP protokolÃ¼ndeki metodlarÄ± kullanarak kaynaklar Ã¼zerinde iÅŸlem yapar.
En sÄ±k kullanÄ±lan metodlar:

GET: Veri sorgulamak (veri Ã§ekmek) iÃ§in
POST: Yeni veri oluÅŸturmak iÃ§in
PUT: Var olan veriyi gÃ¼ncellemek iÃ§in
DELETE: Veriyi silmek iÃ§in
PATCH: Var olan verinin bir kÄ±smÄ±nÄ± gÃ¼ncellemek iÃ§in

Stateless (Durumsuzluk):
REST API, sunucunun her isteÄŸi baÄŸÄ±msÄ±z ve Ã¶ncekilerden baÄŸÄ±msÄ±z olarak ele aldÄ±ÄŸÄ± bir mimaridir.
Yani, sunucu istemcinin Ã¶nceki isteklerine dair bilgiyi saklamaz. Her istek kendi iÃ§inde gerekli tÃ¼m bilgiyi taÅŸÄ±r.

Temsiller (Representations):
Kaynaklar farklÄ± formatlarda temsil edilebilir; en yaygÄ±nlarÄ± JSON ve XMLâ€™dir.
API genellikle JSON formatÄ±nda veri gÃ¶nderir ve alÄ±r Ã§Ã¼nkÃ¼ JSON hafiftir ve Ã§oÄŸu programlama dili tarafÄ±ndan kolay iÅŸlenir.

URI yapÄ±sÄ±:
Kaynaklar hiyerarÅŸik ve mantÄ±klÄ± URI yapÄ±larÄ± ile tanÄ±mlanÄ±r. Ã–rneÄŸin:
/users â†’ TÃ¼m kullanÄ±cÄ±lar
/users/5 â†’ ID'si 5 olan kullanÄ±cÄ±
/users/5/orders â†’ 5 numaralÄ± kullanÄ±cÄ±nÄ±n sipariÅŸleri

| HTTP Metodu | Ä°ÅŸlem                               | URI Ã–rneÄŸi   | AÃ§Ä±klama                                |
| ----------- | ----------------------------------- | ------------ | --------------------------------------- |
| GET         | Veri alma                           | /products    | TÃ¼m Ã¼rÃ¼nleri listeler                   |
| GET         | Belirli veri alma                   | /products/10 | ID'si 10 olan Ã¼rÃ¼nÃ¼ getirir             |
| POST        | Yeni veri oluÅŸturma                 | /products    | Yeni Ã¼rÃ¼n ekler                         |
| PUT         | Var olan veriyi tamamen gÃ¼ncelleme  | /products/10 | ID 10 olan Ã¼rÃ¼nÃ¼ tamamen deÄŸiÅŸtirir     |
| PATCH       | Var olan verinin kÄ±smÄ±nÄ± gÃ¼ncelleme | /products/10 | ID 10 Ã¼rÃ¼nÃ¼n bazÄ± alanlarÄ±nÄ± deÄŸiÅŸtirir |
| DELETE      | Veri silme                          | /products/10 | ID 10 Ã¼rÃ¼nÃ¼ siler                       |

RESTful API TasarÄ±mÄ±nda Ä°yi Pratikler
Ä°simlendirme: Kaynak isimleri Ã§oÄŸul kullanÄ±lÄ±r (/users, /orders).

HTTP durum kodlarÄ±: Ä°steklerin sonucunu belirtmek iÃ§in doÄŸru HTTP kodlarÄ± kullanÄ±lÄ±r.
Ã–rnekler:

200 OK â†’ BaÅŸarÄ±lÄ± GET isteÄŸi
201 Created â†’ BaÅŸarÄ±lÄ± POST ile veri oluÅŸturuldu
204 No Content â†’ BaÅŸarÄ±lÄ± DELETE iÅŸlemi
400 Bad Request â†’ Ä°stek hatalÄ±
404 Not Found â†’ Kaynak bulunamadÄ±
500 Internal Server Error â†’ Sunucu hatasÄ±

Versiyonlama: API geliÅŸtirirken sÃ¼rÃ¼m yÃ¶netimi Ã¶nemlidir. URIâ€™da veya headerâ€™da versiyon belirtilir. Ã–rnek: /api/v1/users

Filtreleme, sÄ±ralama ve sayfalama: BÃ¼yÃ¼k veri setlerinde APIâ€™nin performansÄ± ve kullanÄ±labilirliÄŸi iÃ§in desteklenir.
Ã–rnek: /products?category=electronics&sort=price_asc&page=2

RESTful API NasÄ±l Ã‡alÄ±ÅŸÄ±r? Basit AkÄ±ÅŸ
Ä°stemci (client), bir HTTP isteÄŸi gÃ¶nderir (Ã¶rneÄŸin, GET /users).
Sunucu, isteÄŸi alÄ±r ve ilgili kaynaÄŸÄ± iÅŸler.
Sunucu, isteÄŸe karÅŸÄ±lÄ±k JSON formatÄ±nda veri dÃ¶ner.
Ä°stemci dÃ¶nen veriyi iÅŸler ve kullanÄ±cÄ±ya gÃ¶sterir.

Ã–rnek JSON YanÄ±tÄ±
GET /users/5 isteÄŸine gelen Ã¶rnek cevap:

{
  "id": 5,
  "name": "Atalay Ã–zcan",
  "email": "atalay.ozcan@example.com",
  "createdAt": "2025-07-28T12:00:00Z"
}


Route Templates (Yol ÅablonlarÄ±) Nedir?
Web uygulamalarÄ±nda, Ã¶zellikle RESTful API veya MVC (Model-View-Controller) yapÄ±larÄ±nda, gelen HTTP isteklerinin hangi kod bloÄŸuna yÃ¶nlendirileceÄŸini belirleyen URL kalÄ±plarÄ±dÄ±r.
Yani, URL yapÄ±sÄ± nasÄ±l olacak ve URL iÃ§indeki hangi parÃ§alar (segmentler) hangi verilere karÅŸÄ±lÄ±k gelecek, onu tanÄ±mlayan yapÄ±dÄ±r.

Route Templatesâ€™in Alt BaÅŸlÄ±klarÄ±
1. Route Parameters (Yol Parametreleri)
URL iÃ§erisinde deÄŸiÅŸken parÃ§alardÄ±r.
Bu parametreler, URL'deki belirli bir bÃ¶lÃ¼mÃ¼ temsil eder ve deÄŸer olarak dinamik bilgi alÄ±r.
Genellikle {parametreAdi} ÅŸeklinde tanÄ±mlanÄ±r. 
Ã–rnek: /products/{id}
Burada id bir parametredir.
Ä°stek /products/5 ise, id = 5 olarak alÄ±nÄ±r.
Bu sayede farklÄ± Ã¼rÃ¼nlerin detaylarÄ± aynÄ± route ÅŸablonuyla alÄ±nabilir.

2. Optional Parameters (Opsiyonel Parametreler)
BazÄ± parametrelerin zorunlu deÄŸil, isteÄŸe baÄŸlÄ± olmasÄ±nÄ± saÄŸlar.
Parametre adÄ±nÄ±n sonuna ? iÅŸareti konur.
Ã–rnek:/products/{id?}
Burada id parametresi isteÄŸe baÄŸlÄ±dÄ±r.
/products/5 veya sadece /products istekleri her ikisi de geÃ§erli olur.
Kodda, id parametresi boÅŸ (null) olabilir ve buna gÃ¶re iÅŸlem yapÄ±labilir.

Constraints (KÄ±sÄ±tlamalar)
Parametrelerin alabileceÄŸi deÄŸerleri sÄ±nÄ±rlamak iÃ§in kullanÄ±lÄ±r.
Parametrenin sadece belirli tÃ¼rde veya formattaki deÄŸerleri kabul etmesini saÄŸlar.
Route template iÃ§inde sÃ¼slÃ¼ parantez iÃ§ine : ile kÄ±sÄ±tlama eklenir.

YaygÄ±n kullanÄ±lan constraint Ã¶rnekleri:
| Constraint  | AÃ§Ä±klama                     | Ã–rnek                    |
| ----------- | ---------------------------- | ------------------------ |
| `int`       | Sadece tam sayÄ± kabul eder   | `{id:int}`               |
| `bool`      | Sadece boolean deÄŸer         | `{flag:bool}`            |
| `datetime`  | Tarih formatÄ±nda olmalÄ±      | `{date:datetime}`        |
| `length(3)` | En fazla 3 karakter          | `{code:length(3)}`       |
| `regex()`   | DÃ¼zenli ifadeye uygun olmalÄ± | `{name:regex(^[a-z]+$)}` |

Ã–zet
| Kavram              | TanÄ±m                                                   | Ã–rnek URL            | AÃ§Ä±klama                           |
| ------------------- | ------------------------------------------------------- | -------------------- | ---------------------------------- |
| Route Parameters    | URLâ€™de dinamik veri olarak kullanÄ±lan deÄŸiÅŸken parÃ§alar | `/users/{userId}`    | `userId` deÄŸeri URLâ€™den alÄ±nÄ±r     |
| Optional Parameters | Zorunlu olmayan parametreler                            | `/users/{userId?}`   | `userId` olabilir veya olmayabilir |
| Constraints         | Parametrelerin deÄŸer tipini/formunu sÄ±nÄ±rlayan kural    | `/products/{id:int}` | `id` sadece tam sayÄ± olmalÄ±        |

//Basic Route
app.MapGet("/users/{userId}/posts/{slug}", (int userId, string slug) =>
{
    return $"User ID: {userId}, Post Slug: {slug}";
});

//Constrained Route Parameters
app.MapGet("/products/{id:int:min(1):max(100)}", (int id) =>
{
   return $"Product ID: {id}";
});

//Optional Route Parameters
app.MapGet("/reports/{year?}", (int? year = 2016) =>
{
    return $"Report of the year: {year}";
});

Catch-All Routes (TÃ¼rkÃ§esi: Yakalama RotalarÄ± veya TÃ¼mÃ¼nÃ¼ Yakalama RotalarÄ±), web uygulamalarÄ±nda veya API yÃ¶nlendirmelerinde, 
gelen istek URL'sinin belirli bir kalÄ±ba uymayan veya Ã¶nceden tanÄ±mlanmamÄ±ÅŸ tÃ¼m yollarÄ± yakalamak iÃ§in kullanÄ±lan Ã¶zel bir rota tÃ¼rÃ¼dÃ¼r.

Catch-All Route Nedir?
Gelen URLâ€™de belirtilen ÅŸablona uymayan tÃ¼m URLâ€™leri yakalayan route (yol) ÅŸablonudur.
Genellikle daha esnek ve geniÅŸ kapsamlÄ± yÃ¶nlendirme iÃ§in kullanÄ±lÄ±r.
Ã–zellikle 404 sayfasÄ± (sayfa bulunamadÄ±) veya dinamik iÃ§erik yÃ¼kleme gibi durumlarda faydalÄ±dÄ±r.

NasÄ±l Ã‡alÄ±ÅŸÄ±r?
Normalde routeâ€™lar spesifik ve belirli kalÄ±plara baÄŸlÄ±dÄ±r.
Catch-All route, URLâ€™nin kalan tÃ¼m kÄ±sÄ±mlarÄ±nÄ± tek bir parametre olarak alÄ±r.
Bu parametre sayesinde URLâ€™nin geri kalan kÄ±smÄ± string olarak elde edilir.

Ã–rnek (ASP.NET Coreâ€™da):
// Route template: catch-all parametresi **
[Route("files/{*filepath}")]
public IActionResult GetFile(string filepath)
{
    // filepath parametresi URL'nin files sonrasÄ± tÃ¼m kÄ±smÄ±nÄ± iÃ§erir
    return Content("Ä°stenen dosya yolu: " + filepath);
}
/files/images/photo.jpg isteÄŸi geldiÄŸinde:
filepath = "images/photo.jpg" olur.

/files/docs/report.pdf isteÄŸi geldiÄŸinde:
filepath = "docs/report.pdf" olur.

Neden KullanÄ±lÄ±r?
Dinamik sayfa veya iÃ§erik yÃ¼kleme (CMS uygulamalarÄ± gibi)
Statik dosyalar veya klasÃ¶r yapÄ±larÄ± iÃ§in esnek eriÅŸim
TÃ¼m bilinmeyen URLâ€™leri Ã¶zel olarak yÃ¶netmek (404 sayfalarÄ± iÃ§in)
URL parametrelerini toplu almak

| Terim           | AnlamÄ±                                                         |
| --------------- | -------------------------------------------------------------- |
| Catch-All Route | URLâ€™nin kalan tÃ¼m kÄ±smÄ±nÄ± tek parametreyle yakalayan rota tipi |
| KullanÄ±m AlanÄ±  | Dosya yollarÄ±, dinamik iÃ§erik, 404 sayfa yÃ¶netimi              |

//Catch-all Route Parameter
app.MapGet("/files/{*filePath}", (string filePath) =>
{
    return $"Requested file path: {filePath}";
});

Query Parameters Nedir?
Query Parameters (Sorgu Parametreleri), bir HTTP isteÄŸinde URL'nin sonunda, genellikle veri filtrelemek, sÄ±ralamak, arama yapmak veya sayfalama gibi iÅŸlemler iÃ§in kullanÄ±lan anahtar-deÄŸer Ã§iftleridir.

YapÄ± (SÃ¶z Dizimi):
https://example.com/products?category=electronics&sort=price_asc
Bu URLâ€™de:
? â†’ Sorgu parametrelerinin baÅŸladÄ±ÄŸÄ±nÄ± gÃ¶sterir.
category=electronics â†’ category adÄ±nda bir parametre, deÄŸeri electronics
& â†’ Birden fazla parametre arasÄ±nda ayraÃ§ olarak kullanÄ±lÄ±r.
sort=price_asc â†’ sort adÄ±nda baÅŸka bir parametre, deÄŸeri price_asc

| KullanÄ±m AlanÄ±          | AÃ§Ä±klama                                    |
| ----------------------- | ------------------------------------------- |
| ğŸ” Arama                | `?q=telefon` â†’ "telefon" kelimesiyle ara    |
| ğŸ—‚ï¸ Filtreleme          | `?category=books` â†’ Sadece kitaplarÄ± gÃ¶ster |
| ğŸ”ƒ SÄ±ralama             | `?sort=price_desc` â†’ FiyatÄ±na gÃ¶re sÄ±rala   |
| ğŸ“„ Sayfalama            | `?page=2&limit=10` â†’ 2. sayfa, 10 Ã¼rÃ¼n      |
| ğŸ”§ Ayarlar / seÃ§enekler | `?showDetails=true` â†’ DetaylarÄ± gÃ¶ster      |

 Ã–rnek URL ve AnlamÄ±:
https://api.example.com/users?age=30&sort=name_desc&page=2
AnlamÄ±:
age=30 â†’ 30 yaÅŸÄ±ndaki kullanÄ±cÄ±larÄ± getir
sort=name_desc â†’ Ä°sme gÃ¶re azalan sÄ±rala
page=2 â†’ Ä°kinci sayfadaki sonuÃ§larÄ± gÃ¶ster

Ã–zetle:
Query Parameters, URLâ€™ye ? ile eklenen, veri alma isteklerinde filtreleme, arama, sÄ±ralama ve sayfalama gibi iÅŸlemleri kontrol etmemizi saÄŸlayan anahtar-deÄŸer Ã§iftleridir. 
Uygulamalarda API endpointâ€™lerine esneklik ve detaylÄ± sorgu gÃ¼cÃ¼ kazandÄ±rÄ±r.

//Route with Query Parameters
app.MapGet("/search", (string? q, int page = 1) =>
{                                                              https://localhost:7053/search?q=dotnet&page=2
    return $"Searching for {q} on page {page}";
});  
**Path kÄ±smÄ±nda boÅŸluk bÄ±rakmamaya Ã¶zen gÃ¶stermeli hata almadÄ±m fakat 404 Ã§evirdi o yÃ¼zden path iÃ§inde space yapÄ±lmamalÄ±!


CRUD API'S

The main code: 
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var blogs = new List<Blog>
{
    new Blog { Title = "First Blog", Body = "This is the body of the first blog." },
    new Blog { Title = "Second Blog", Body = "This is the body of the second blog." }
};

app.MapGet("/", () => "Hello World!");

app.MapGet("/blogs", () =>
{
    return blogs;
});

app.Run();

public class Blog
{
    public required string Title { get; set; }
    public required string Body { get; set; }
}

READ CRUDE (GET)
app.MapGet("/blogs/{id}", (int id) =>
{
    if(id >= 1 && id <= blogs.Count)
    {
        return Results.Ok(blogs[id - 1]);
    }
    else
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
});

CREATE CRUDE (POST)
//Create a new blog
app.MapPost("/blogs", (Blog blog) =>{ List nesnesi oluÅŸturuyoruz, Ã§Ã¼nkÃ¼ listeye yeni eleman eklememiz lazÄ±m. Results.Created() ASP.NET Core Minimal APIâ€™de HTTP 201 Created yanÄ±tÄ± dÃ¶ndÃ¼rmek iÃ§in kullanÄ±lan bir yardÄ±mcÄ± metottur.
    blogs.Add(blog);
    return Results.Created($"/blogs/{blogs.Count -1}", blog);
});

DELETE CRUDE (DELETE)
app.MapDelete("/blogs/{id}", (int id) => {
    if(id >= 1 && id <= blogs.Count)
    {
        blogs.RemoveAt(id -1 );
        return Results.NoContent(); //204 No Content? HTTP 204 durumu, bir isteÄŸin (genelde PUT, DELETE) baÅŸarÄ±yla iÅŸlendiÄŸini fakat sunucunun dÃ¶ndÃ¼recek iÃ§eriÄŸi olmadÄ±ÄŸÄ±nÄ± belirtir.
    }
    else    
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
});

UPDATE CRUDE (PUT)
//Update a blog
app.MapPut("/blogs/{id}", (int id, Blog blog) =>
{
    if (id >= 1 && id <= blogs.Count)
    {
        blogs[id - 1] = blog; // Update the blog at the specified index
        return Results.Ok($"Updated: {blog}");
    }
    else
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
});


HttpLogging middleware, ASP.NET Coreâ€™da istek (request) ve yanÄ±t (response) ile ilgili HTTP bilgilerini loglamak (kayÄ±t altÄ±na almak) iÃ§in kullanÄ±lan yerleÅŸik (built-in) bir middleware'dir.

Temel TanÄ±m:
HttpLoggingMiddleware, HTTP trafiÄŸini incelemek iÃ§in geliÅŸtiricilere yardÄ±mcÄ± olur.
Gelen isteÄŸin ve giden yanÄ±tÄ±n bazÄ± detaylarÄ±nÄ± loglayarak hata ayÄ±klama (debugging), performans izleme veya gÃ¼venlik analizleri iÃ§in veri saÄŸlar.

Dikkat Edilmesi Gerekenler
GeliÅŸtirme ortamÄ±nda Ã§ok faydalÄ±dÄ±r. Ãœretim ortamÄ±nda dikkatli kullanÄ±lmalÄ±dÄ±r Ã§Ã¼nkÃ¼:
Hassas verileri loga yazÄ±labilir (ÅŸifre, token vb.).
Performans etkilenebilir.
Loglar ÅŸiÅŸebilir (Ã¶zellikle RequestBody ve ResponseBody aktifse).

Ne Zaman KullanÄ±lÄ±r?
API geliÅŸtirme sÃ¼recinde gelen/giden veriyi gÃ¶rmek istiyorsan.
HatalÄ± istekleri incelemek, Ã¶rneÄŸin 400 ya da 500 hatalarÄ±nda ne gÃ¶nderilmiÅŸ gÃ¶rmek istiyorsan.
Performans ya da gÃ¼venlik analizleri iÃ§in log toplamak istiyorsan.
Log, gÃ¼venlik kamerasÄ± gibi: SÃ¼rekli kayÄ±t alÄ±r, sonra aÃ§Ä±p ne olduÄŸunu gÃ¶rebilirsin.

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddHttpLogging((o) => { }); // Configure HttpLogging options if needed
var app = builder.Build();
app.UseHttpLogging();// Use the HttpLogging middleware
app.MapGet("/", () => "Hello World!");
app.Run();

AyrÄ±ca appsetting.json dosyasÄ±nÄ±n iÃ§ine ÅŸu satÄ±rÄ± ekliyoruz. 

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware": "Information" //EKLENEN SATIR
    }
  },
  "AllowedHosts": "*"
}

ASP.NET Core'da Pipeline (Ä°ÅŸlem Boru HattÄ±) nedir?
ASP.NET Coreâ€™da pipeline, bir HTTP isteÄŸinin (request) uygulamaya girdikten sonra iÅŸlem gÃ¶receÄŸi middleware zinciridir.

Bu zincirden geÃ§en her middleware:
Ä°steÄŸi deÄŸiÅŸtirebilir
Kendi gÃ¶revini yapabilir (Ã¶rneÄŸin loglama, yetki kontrolÃ¼)
Bir sonraki middleware'e paslayabilir
Veya zinciri burada kesebilir (Ã¶rneÄŸin hata dÃ¶ner)

Ä°stek-Response AkÄ±ÅŸÄ± (Request â†’ Middleware â†’ Response)
TarayÄ±cÄ±dan GET /home isteÄŸi gÃ¶nderilir.
Bu istek ASP.NET Core pipeline'a girer.
SÄ±rasÄ±yla tÃ¼m app.Use(...) middlewareâ€™leri Ã§alÄ±ÅŸÄ±r.
Her middleware isterse:
Ä°ÅŸlemini yapar
await next(); Ã§aÄŸÄ±rarak bir sonrakine geÃ§er
Sonunda bir yanÄ±t oluÅŸturulur (Response) ve pipeline'dan geri yukarÄ±ya doÄŸru dÃ¶ner.

ğŸ“¦ Ã–rnek Middleware Zinciri
app.UseHttpsRedirection();    // 1. middleware â†’ HTTP'yi HTTPS'e yÃ¶nlendirir
app.UseRouting();             // 2. middleware â†’ URL'yi analiz eder
app.UseAuthentication();      // 3. middleware â†’ Kimlik doÄŸrulamasÄ± yapar
app.UseAuthorization();       // 4. middleware â†’ Yetki kontrolÃ¼ yapar
app.UseEndpoints(...);        // 5. middleware â†’ Endpoint'i Ã§alÄ±ÅŸtÄ±rÄ±r (Ã¶rneÄŸin controller)

Neden Bu Sistem KullanÄ±lÄ±yor?
ModÃ¼lerlik: Her gÃ¶rev kendi middleware'inde tanÄ±mlanÄ±r.
Esneklik: Ä°stediÄŸin middlewareâ€™i kolayca ekleyebilir/Ã§Ä±kartabilirsin.
Kontrol: Zincirin hangi noktasÄ±nda ne olduÄŸunu gÃ¶rebilirsin.
Performans: Gereksiz iÅŸler yapÄ±lmaz; zincir erken kesilebilir.

Pipeline, gelen HTTP isteklerinin bir iÅŸlem tÃ¼neline (boru hattÄ±na) sokulmasÄ±dÄ±r.
Bu tÃ¼nelde her middleware kendi iÅŸini yapar veya durumu bir sonrakine devreder.

"Pipeline bir sÄ±ralama mekanizmasÄ±. Ã–nce hangi middleware'i seÃ§eceÄŸim, neyi yapmasÄ±nÄ± sÃ¶yleyeceÄŸim... SÄ±ralamayÄ± kurduÄŸumda aslÄ±nda bir pipeline yaratmÄ±ÅŸ oluyorum."

app.UseMiddleware1();
app.UseMiddleware2();
app.UseMiddleware3(); gibi her app.Use(...), pipeline'a bir middleware ekler ve bu sÄ±ralama, isteÄŸin iÅŸlenme sÄ±rasÄ±nÄ± belirler.

Basit MantÄ±k:
Pipeline = "Ä°stek geldiÄŸinde ÅŸunlarÄ± ÅŸu sÄ±rayla yap:"
Redirect mi edeceÄŸim? â†’ app.UseHttpsRedirection()
Statik dosya mÄ±? â†’ app.UseStaticFiles()
Rotalar Ã§alÄ±ÅŸsÄ±n mÄ±? â†’ app.UseRouting()
GiriÅŸ yapÄ±ldÄ± mÄ±? â†’ app.UseAuthentication()
Yetkisi var mÄ±? â†’ app.UseAuthorization()
Uygulama ne cevap verecek? â†’ app.UseEndpoints(...)

SonuÃ§:
Pipeline: Middleware zinciridir.
Sen middleware'leri app.Use() ile sÄ±ralarsÄ±n.
Bu sÄ±ralama, her HTTP isteÄŸinin nasÄ±l iÅŸleneceÄŸini belirler.
Ä°lk gelen middleware, Ã¶nce Ã§alÄ±ÅŸÄ±r; await next() diyerek zinciri devam ettirir.
Ä°stersen zinciri bir yerde kesebilirsin (Ã¶rneÄŸin: app.Run()).

app.Use(async (context, next) =>
{
    //logic here
    await next.Invoke();
    //logic here
});
Bu kod, app.Use(...) ile anonim (isimsiz) bir middleware tanÄ±mlar.

Ä°ÅŸte bu yapÄ± ÅŸunu yapar:
context â†’ Gelen HTTP isteÄŸi (HttpContext)
next â†’ Zincirdeki bir sonraki middlewareâ€™i temsil eder
await next.Invoke() â†’ Zinciri bir sonrakine geÃ§irir

Ne iÅŸe yarar?
Ä°stek geldiÄŸinde bu middleware Ã§alÄ±ÅŸÄ±r.
Kendi baÅŸÄ±na bir ÅŸey yapmaz, sadece zinciri devam ettirir.
Genellikle Ã¶ncesinde veya sonrasÄ±nda iÅŸlem yapÄ±lÄ±r.

Yani bu custom middleware ayrÄ±ca iÃ§erisinde birden fazla mantÄ±k sÄ±rasÄ± kurabilirim.

Middleware akÄ±ÅŸ sÄ±ralamasÄ± iu ÅŸekilde oluyor.

app.Use(async (context, next) =>
{
    Console.WriteLine("Before LOGÄ°C 100");
    await next.Invoke();
    Console.WriteLine("After LOGÄ°C 100");
});                                        Ä°lk sÄ±rada 1)BEFORE 100 2)BEFORE 200 3)AFTER 200 4) AFTER 100 
app.Use(async (context, next) =>
{
    Console.WriteLine("Before LOGÄ°C 200");
    await next.Invoke();
    Console.WriteLine("After LOGÄ°C 200");
});

ControllerBase Nedir?
ControllerBase, ASP.NET Coreâ€™da sadece API geliÅŸtiren controllerâ€™lar iÃ§in hazÄ±rlanmÄ±ÅŸ bir soyut sÄ±nÄ±ftÄ±r (abstract class).

public class MyApiController : ControllerBase
{
    // API endpoint'leri buraya yazÄ±lÄ±r
}
Neden ControllerBase Miras AlÄ±nÄ±r?
ControllerBase, sana ÅŸu hazÄ±r yetenekleri kazandÄ±rÄ±r:
| Ã–zellik                                                                          | AÃ§Ä±klama |
| -------------------------------------------------------------------------------- | -------- |
| âœ… `[Route]`, `[HttpGet]`, `[HttpPost]` gibi attribute'lar kullanÄ±labilir olur    |          |
| âœ… `ModelState` kontrolÃ¼ yapÄ±labilir                                              |          |
| âœ… `Ok()`, `BadRequest()`, `NotFound()` gibi hazÄ±r yanÄ±t metodlarÄ± kullanÄ±labilir |          |
| âœ… `Request`, `Response`, `User`, `HttpContext` gibi Ã¶zelliklere eriÅŸim saÄŸlanÄ±r  |          |
| âœ… `ActionResult<T>` dÃ¶nÃ¼ÅŸleriyle standart API yapÄ±larÄ± sunulur                   |          |

ASP NET CORE WEB API PRODUCT SINIFI

namespace MyFirstWebApi.Models
{
    public class Product
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public decimal Price { get; set; }
    }
}

ASP NET CORE WEB API CONTROLLER SINIFI

namespace MyFirstWebApi.Controllers
{
    using Microsoft.AspNetCore.Mvc;
    using MyFirstWebApi.Models;
    using System.Collections.Generic;
    using System.Linq;

    [Route("api/products")]
    [ApiController]
    public class ProductController : ControllerBase 
    {
        private static List<Product> products = new List<Product>();

        [HttpGet]// Route to get all products
        public ActionResult<List<Product>> GetAll() => products; // Returns all products

        
        [HttpGet("{id}")]// Route to get a product by ID
        public ActionResult<Product> GetById(int id)
        {
            var product = products.FirstOrDefault(p => p.Id == id); // Finds product by ID 
            return product !=null ? Ok(product) : NotFound(); // Returns product by ID or 404 if not found
        }

        [HttpPost] // Route to create a new product
        public ActionResult<Product> Create(Product newProduct)
        {
            newProduct.Id = products.Count + 1; // Assigns a new ID based on the current count
            products.Add(newProduct); // Adds the new product to the list
            return CreatedAtAction(nameof(GetById), new { id = newProduct.Id }, newProduct); // Returns 201 Created with the new product
        }

        [HttpPut("{id}")] // Route to update an existing product
        public ActionResult Update(int id, Product updatedProduct)
        {
            var product = products.FirstOrDefault(p => p.Id == id); // Finds product by ID
            if (product == null) return NotFound(); // Returns 404 if product not found

            product.Name = updatedProduct.Name; // Updates product properties
            product.Description = updatedProduct.Description;
            product.Price = updatedProduct.Price;
            return Ok(product); // Returns the updated product
        }

        [HttpPatch("{id}")] // Route to partially update a product
        public ActionResult MiniUpdate(int id, Product miniUpdatedProduct)
        {
            var product = products.FirstOrDefault(p => p.Id == id);
            if (product == null) return NotFound();

            product.Id = miniUpdatedProduct.Id; // Updates only the price
            return Ok(product); // Returns the updated product
        }

        [HttpDelete("{id}")] // Route to delete a product
        public ActionResult Delete(int id)
        {
            var product = products.FirstOrDefault(p => p.Id == id); // Finds product by ID
            if (product == null) return NotFound(); // Returns 404 if product not found

            products.Remove(product); // Removes the product from the list
            return NoContent(); // Returns 204 No Content
        }

    }
}

LINQ Nedir?
LINQ (Language Integrated Query) = â€œDile Entegre EdilmiÅŸ Sorguâ€ anlamÄ±na gelir.

C# gibi .NET dillerinde;
Listeler,
Diziler,
VeritabanÄ± tablolarÄ±,
JSON,
XML gibi veriler Ã¼zerinde
SQL'e benzer bir yapÄ±yla arama, filtreleme, sÄ±ralama, seÃ§me, gruplama gibi iÅŸlemleri yapmamÄ±zÄ± saÄŸlar.

LINQ Ne AmaÃ§la KullanÄ±lÄ±r?
LINQâ€™in amacÄ±:

Koleksiyonlar (Ã¶rneÄŸin List<Product>) Ã¼zerinde veri iÅŸleme iÅŸlerini daha sade, okunabilir ve gÃ¼venli hale getirmektir.

Geleneksel YÃ¶ntem
List<Product> result = new List<Product>();
foreach (var p in products)
{
    if (p.Price > 1000)
        result.Add(p);
}

LINQ ile
var result = products.Where(p => p.Price > 1000).ToList();

LINQ Hangi senaryolarda gerekli?
| Senaryo                    | AÃ§Ä±klama                                               |
| -------------------------- | ------------------------------------------------------ |
| ğŸ” **Filtreleme**          | `Where()` ile belli koÅŸullardaki verileri seÃ§me        |
| ğŸ”¢ **SÄ±ralama**            | `OrderBy()` veya `OrderByDescending()`                 |
| ğŸ” **Arama**               | `FirstOrDefault()`, `Find()` gibi                      |
| ğŸ“Š **Gruplama**            | `GroupBy()` kullanarak istatistik                      |
| ğŸ¯ **SeÃ§im / Projeksiyon** | `Select()` ile sadece bazÄ± alanlarÄ± almak              |
| ğŸ§© **BirleÅŸtirme (Join)**  | FarklÄ± koleksiyonlarÄ± SQL gibi birleÅŸtirme             |
| ğŸ“š **Aggregate iÅŸlemler**  | `Count()`, `Sum()`, `Average()` gibi toplama iÅŸlemleri |

Ã–zetle:
LINQ, daha temiz ve sade kod yazmak iÃ§indir.
KoleksiyonlarÄ± sorgulamak iÃ§in kullanÄ±lÄ±r.
List, Array, Dictionary, EF DbContext gibi veri koleksiyonlarÄ± Ã¼zerinde iÅŸlem yaparken Ã§ok gereklidir.
Ã–zellikle backend geliÅŸtirme, veri iÅŸleme, API ve raporlama sistemleri gibi senaryolarda neredeyse kaÃ§Ä±nÄ±lmazdÄ±r.

Kodumda Olan Linq
FirstOrDefault
var product = products.FirstOrDefault(p => p.Id == id);
Ne yapar?
products listesinden Id'si eÅŸleÅŸen ilk Ã¼rÃ¼nÃ¼ bulur.
Yoksa null dÃ¶ner.

LINQ ifadelerinde genelde ÅŸu yapÄ±lar kullanÄ±lÄ±r:
Where(...) â†’ Filtreleme (birden fazla sonucu dÃ¶ner)
FirstOrDefault(...) â†’ Ä°lk uyumlu sonucu dÃ¶ner, yoksa null
Any(...) â†’ En az bir tane uyumlu eleman var mÄ± diye bakar (bool dÃ¶ner)
Select(...) â†’ Liste iÃ§inden belirli alanlarÄ± seÃ§er
OrderBy(...) / OrderByDescending(...) â†’ SÄ±ralama

Interface Nedir?
Interface, bir sÄ±nÄ±fÄ±n (class) hangi metotlarÄ± ve Ã¶zellikleri (property) iÃ§ermesi gerektiÄŸini tanÄ±mlayan, ama kendisi bu metotlarÄ±n iÃ§ini yazmayan (implementation iÃ§ermeyen) yapÄ±dÄ±r.

AmaÃ§:
SÃ¶zleÅŸme (contract) gibi dÃ¼ÅŸÃ¼n.
Bir interface, â€œBu metotlar mutlaka bu sÄ±nÄ±fta olacakâ€ der.
NasÄ±l yapÄ±lacaÄŸÄ± ise sÄ±nÄ±fa bÄ±rakÄ±lÄ±r.

Neden KullanÄ±lÄ±r?
FarklÄ± sÄ±nÄ±flarÄ±n aynÄ± metotlarÄ± tutmasÄ±nÄ± saÄŸlamak iÃ§in.
Kodda esneklik, modÃ¼lerlik ve test edilebilirlik iÃ§in.
Polimorfizm (Ã§ok biÃ§imlilik) iÃ§in temel yapÄ±.

Syntax (Ã–rnek)
public interface IHayvan
{
    void SesCikar();
}
Burada IHayvan isimli bir interface var.
SesCikar() metodu kesinlikle bu interfaceâ€™i implemente eden sÄ±nÄ±flarda olacak ama nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ± sÄ±nÄ±flara kalmÄ±ÅŸ.

Interfaceâ€™i Kullanan SÄ±nÄ±flar:
public class Kedi : IHayvan
{
    public void SesCikar()
    {
        Console.WriteLine("Miyav");
    }
}

public class Kopek : IHayvan
{
    public void SesCikar()
    {
        Console.WriteLine("Hav");
    }
}

AvantajlarÄ±:
Kodun baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± azaltÄ±r (loosely coupled olur).
FarklÄ± sÄ±nÄ±flar aynÄ± interfaceâ€™i implemente edebilir.
Testlerde mock nesne oluÅŸturmayÄ± kolaylaÅŸtÄ±rÄ±r.
BÃ¼yÃ¼k projelerde farklÄ± modÃ¼lleri standartlaÅŸtÄ±rÄ±r.

| Interface                       | SÄ±nÄ±f (Class)                          |
| ------------------------------- | -------------------------------------- |
| Sadece metot ve property imzasÄ± | MetotlarÄ±n ve Ã¶zelliklerin iÃ§ini yazar |
| SÃ¶zleÅŸme (contract)             | SÃ¶zleÅŸmeye uyan somut nesne            |
| Ã‡oklu implemente edilebilir     | Tekil implementasyon                   |

readonly Nedir?
readonly, bir alanÄ±n (field) deÄŸerinin sadece:
TanÄ±mlandÄ±ÄŸÄ± anda (field tanÄ±mÄ± sÄ±rasÄ±nda)
Constructor (yapÄ±cÄ± metod) iÃ§inde
atanmasÄ±na izin verir. BunlarÄ±n dÄ±ÅŸÄ±nda deÄŸiÅŸtirilmesi yasaktÄ±r.

ğŸ¯ Ne Ä°ÅŸe Yarar?
Bir deÄŸerin nesne oluÅŸturulduktan sonra deÄŸiÅŸtirilememesini garanti altÄ±na alÄ±r.
Immutable (deÄŸiÅŸmez) nesneler veya sabitlik isteyen senaryolarda Ã§ok kullanÄ±lÄ±r.
const ile farkÄ±: const tamamen sabittir ve compile time'da deÄŸeri bilinir, readonly ise runtime'da constructorâ€™da belirlenebilir.

public class Product
{
    public readonly string Brand;

    public Product(string brand)
    {
        Brand = brand; // âœ… Sadece constructor iÃ§inde atanabilir
    }

    public void ChangeBrand(string newBrand)
    {
        // Brand = newBrand; âŒ Derleme hatasÄ± verir!
    }
}

const vs readonly
| Ã–zellik             | `const`                            | `readonly`                               |
| ------------------- | ---------------------------------- | ---------------------------------------- |
| Ne zaman atanÄ±r     | Derleme zamanÄ±nda (`compile time`) | Ã‡alÄ±ÅŸma zamanÄ±nda (`runtime`)            |
| Nerede atanabilir   | TanÄ±mlandÄ±ÄŸÄ± yerde                 | TanÄ±mlandÄ±ÄŸÄ± yerde veya constructorâ€™da   |
| DeÄŸiÅŸtirilebilir mi | HayÄ±r                              | HayÄ±r (sadece constructorâ€™da atanabilir) |
| KullanÄ±m amacÄ±      | DeÄŸiÅŸmez sabit deÄŸerler            | Nesne baÅŸÄ±na deÄŸiÅŸmeyecek deÄŸerler       |

Ne Zaman KullanÄ±lÄ±r?
AynÄ± nesne iÃ§in deÄŸiÅŸmemesi gereken ama farklÄ± nesneler iÃ§in farklÄ± olabilecek deÄŸerlerde.
Ã–rneÄŸin id, createdAt, initialStatus gibi verilerde Ã§ok yaygÄ±ndÄ±r

Ã–RNEK DEPENDENCY INJECTION
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddTransient<IMyService, MyService>();

var app = builder.Build();

app.Use(async (context, next) =>
{
    var myService = context.RequestServices.GetRequiredService<IMyService>();
    myService.LogCreation("Middleware invoked First");
    await next.Invoke();
});

app.Use(async (context, next) =>
{
    var myService = context.RequestServices.GetRequiredService<IMyService>();
    myService.LogCreation("Middleware invoked Second");
    await next.Invoke();
});

app.MapGet("/", (IMyService myService) =>
{
    myService.LogCreation("MyService instance created");
    return Results.Ok("Hello, World! MyService instance created successfully.");
});

app.Run();

public interface IMyService
{
    void LogCreation(string message);
}

public class MyService : IMyService
{
    private readonly int _serviceId;

    public MyService()
    {
        _serviceId = new Random().Next(100000, 999999);
    }

    public void LogCreation(string message)
    {
        Console.WriteLine($"{message} - Service ID: {_serviceId}");
    }
}

. builder.Services.AddTransient<IMyService, MyService>();
ğŸ“Œ AnlamÄ±:
Bu satÄ±rda IMyService interfaceâ€™ini MyService sÄ±nÄ±fÄ± ile eÅŸleÅŸtiriyoruz.
Transient olarak kaydediyoruz, yani:
Bu servis her istendiÄŸinde yeni bir MyService Ã¶rneÄŸi oluÅŸturulacak.

ğŸ“¦ Neden burada yazÄ±yoruz?
builder.Services nesnesi ASP.NET Core'un yerleÅŸik DI konteyneridir.
AddTransient, AddScoped, AddSingleton gibi metodlarla servis yaÅŸam sÃ¼resi belirlenir.
| YaÅŸam SÃ¼resi | AnlamÄ±                         |
| ------------ | ------------------------------ |
| `Transient`  | Her kullanÄ±mda yeni nesne      |
| `Scoped`     | HTTP isteÄŸi baÅŸÄ±na bir nesne   |
| `Singleton`  | TÃ¼m uygulama boyunca tek nesne |

Interface & SÄ±nÄ±f: IMyService ve MyService
public interface IMyService
{
    void LogCreation(string message);
}

public class MyService : IMyService
{
    private readonly int _serviceId;

    public MyService()
    {
        _serviceId = new Random().Next(100000, 999999);
    }

    public void LogCreation(string message)
    {
        Console.WriteLine($"{message} - Service ID: {_serviceId}");
    }
}
Ne Anlama Geliyor?
IMyService: Bir interface tanÄ±mÄ±dÄ±r. Ne yapÄ±lacaÄŸÄ±nÄ± sÃ¶yler.
MyService: Onu uygulayan (implement eden) somut sÄ±nÄ±ftÄ±r. Ne yapÄ±lacaÄŸÄ±nÄ± anlatan interfaceâ€™in nasÄ±l yapÄ±lacaÄŸÄ±nÄ± iÃ§erir.

DI Neden Interface ister?
Gelecekte MyService yerine baÅŸka bir sÄ±nÄ±f (MockMyService, LoggingService vs.) kullanÄ±labilir.
GevÅŸek baÄŸlÄ± (loosely coupled) ve test edilebilir sistemler inÅŸa edilir.

Ã–ZETLE
| BÃ¶lÃ¼m                            | GÃ¶rev                                |
| -------------------------------- | ------------------------------------ |
| `builder.Services.AddTransient`  | DI sistemine kayÄ±t (baÄŸlantÄ± kurma)  |
| `IMyService` interface           | BaÄŸÄ±mlÄ±lÄ±k noktasÄ±                   |
| `MyService` class                | Somut baÄŸÄ±mlÄ±lÄ±k (implementation)    |
| `context.RequestServices...`     | DI konteyner'dan elle alma           |
| `app.MapGet("/", (IMyService...` | DI ile doÄŸrudan injection (otomatik) |

Middleware KÄ±smÄ±
app.Use(async (context, next) =>
{
    var myService = context.RequestServices.GetRequiredService<IMyService>();
    myService.LogCreation("Middleware invoked First");
    await next.Invoke();
});
Bu app.Use(...) ne iÅŸe yarÄ±yor?
ASP.NET Coreâ€™da app.Use(...), Middleware eklemek iÃ§in kullanÄ±lÄ±r.
Middleware: HTTP isteÄŸi geldiÄŸinde iÅŸlem yapabilen bir ara katmandÄ±r.
Bu kod, gelen her HTTP isteÄŸinde devreye giren bir parÃ§adÄ±r.

1. app.Use(async (context, next) => { ... })
Yeni bir anonim middleware tanÄ±mlÄ±yoruz.
context: Ä°steÄŸe dair tÃ¼m bilgileri barÄ±ndÄ±ran HttpContext nesnesidir.
next: SÄ±radaki middlewareâ€™i temsil eder. await next.Invoke(); yazmazsak zincir kÄ±rÄ±lÄ±r.

2. var myService = context.RequestServices.GetRequiredService<IMyService>();
Bu satÄ±r ne yapar?
context.RequestServices: HTTP isteÄŸi iÃ§in geÃ§erli olan DI konteynerâ€™Ä± dÃ¶ner.
GetRequiredService<IMyService>(): DI sisteminden IMyService tipinde bir nesne ister.

3. myService.LogCreation("Middleware invoked First");
Az Ã¶nce alÄ±nan MyService nesnesinin LogCreation metodunu Ã§aÄŸÄ±rÄ±yoruz.
Bu sayede o middleware'in Ã§alÄ±ÅŸtÄ±ÄŸÄ± anda servis Ã¶rneÄŸi yaratÄ±lÄ±r ve mesaj konsola yazÄ±lÄ±r.

4. await next.Invoke();
Bu satÄ±r olmazsa zincirdeki bir sonraki middleware Ã§alÄ±ÅŸmaz.
Yani sonraki app.Use(...) veya app.MapGet(...) Ã§alÄ±ÅŸmaz.
await ile Ã§aÄŸrÄ±lmasÄ±, asenkron iÅŸlemleri dÃ¼zgÃ¼n yÃ¶netmek iÃ§indir.

| Kod ParÃ§asÄ±                        | GÃ¶revi                                     |
| ---------------------------------- | ------------------------------------------ |
| `context.RequestServices`          | O anki HTTP isteÄŸine Ã¶zel DI konteyner     |
| `GetRequiredService<IMyService>()` | Servisi konteyner'dan Ã§ek (yoksa hata ver) |
| `LogCreation(...)`                 | Servis Ã¶rneÄŸini kullandÄ±rarak iÅŸlem yap    |
| `await next.Invoke()`              | Zincirdeki bir sonraki middleware'e geÃ§    |


try-catch BloÄŸu Nedir? AmacÄ± Nedir?
try-catch, C# ve ASP.NET Core dahil birÃ§ok dilde kullanÄ±lan bir hata yakalama yapÄ±sÄ±dÄ±r. AmaÃ§:
Hata (exception) oluÅŸabilecek kodlarÄ± try bloÄŸuna almak.
Hata olursa, uygulamanÄ±n Ã§Ã¶kmesini engellemek ve hata durumunu kontrol etmek.
HatalÄ± duruma uygun bir tepki (mesaj, log, yÃ¶nlendirme, vs.) vermek.

Basit MantÄ±ÄŸÄ±
try
{
    // Hata Ã§Ä±kabilecek kodlar buraya
}
catch (Exception ex)
{
    // Hata olursa burasÄ± Ã§alÄ±ÅŸÄ±r
}

0'A BÃ–LME Ã–RNEÄÄ°
try
{
    int a = 10;
    int b = 0;
    int sonuc = a / b; // Burada hata olur
    Console.WriteLine("SonuÃ§: " + sonuc);
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("SÄ±fÄ±ra bÃ¶lme hatasÄ±: " + ex.Message);
}

Global Error Handling Nedir?
Global error handling (kÃ¼resel hata yÃ¶netimi):
Uygulama genelinde oluÅŸabilecek tÃ¼m hatalarÄ± merkezi bir noktada yakalamayÄ± saÄŸlar.
Tek tek her endpointâ€™e try-catch yazmak yerine, ortak bir hata yakalama mekanizmasÄ± kurulmuÅŸ olur.
Ã–zellikle web projelerinde, kullanÄ±cÄ±ya "Sunucu hatasÄ±", "LÃ¼tfen tekrar deneyin" gibi anlamlÄ± mesajlar gÃ¶stermek iÃ§in kullanÄ±lÄ±r.

Ã–rnek
app.Use(async (context, next) =>
{
    try
    {
        await next(); // Ä°steÄŸi bir sonraki middleware'e gÃ¶nder
    }
    catch (DivideByZeroException ex)
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsJsonAsync(new { error = "SÄ±fÄ±ra bÃ¶lme hatasÄ± oluÅŸtu!" });
    }
    catch (Exception ex)
    {
        context.Response.StatusCode = 500;
        await context.Response.WriteAsJsonAsync(new { error = "Bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin." });
    }
});

// === Ã–rnek Endpoint ===
app.MapGet("/bol", (int a, int b) =>
{
    return Results.Ok(a / b); // b = 0 girilirse hata oluÅŸur
});

ASP.NET Coreâ€™da Logging (KayÄ±t Tutma) Nedir?
Logging, uygulamada olan olaylarÄ±n (Ã¶rneÄŸin hatalar, uyarÄ±lar, bilgi mesajlarÄ±) kaydÄ±nÄ± tutmaktÄ±r. Bu sayede:
Hatalar tespit edilir,
DavranÄ±ÅŸlar izlenir,
Sistem izleme/log sunucularÄ±na veri gÃ¶nderilir (Ã¶rnek: Serilog, Seq, Kibana vs.).

