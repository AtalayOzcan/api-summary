API nedir, ne işe yarar?
API, farklı yazılım uygulamalarının veya sistemlerin birbirleriyle iletişim kurmasını sağlayan bir arayüzdür. Yani, bir programın başka bir programla "konuşmasını" mümkün kılar.

Minimal API, ASP.NET Core’da, Controller sınıfları, Startup.cs, IActionResult, routing attributes gibi yapılar olmadan doğrudan Program.cs dosyasında basit ve sade bir biçimde HTTP endpoint’leri tanımlamana olanak tanıyan bir yaklaşımdır.
"Minimal kod, maksimum iş" felsefesiyle REST API'leri oluşturmanı sağlar.

| Özellik                               | Açıklama                                     |
| ------------------------------------- | -------------------------------------------- |
| 🔸 Basit yapı                         | Sadece `Program.cs` yeterli                  |
| 🔸 Hızlı başlangıç                    | Controller, Startup, Service yapısı gerekmez |
| 🔸 Performans odaklı                  | Gereksiz abstraction yoktur, daha hızlıdır   |
| 🔸 Geliştirici dostu                  | Az satırla çok iş yapılır                    |
| 🔸 Test ve küçük servisler için ideal | Mikro servis yapıları için uygundur          |

Örnek MinimalApi
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "Hello World!");
app.MapGet("/hello", () => "Merhaba!");
app.MapGet("/square/{number}", (int number) => number * number);

app.Run();

| Klasik ASP.NET Core                   | Minimal API                    |
| ------------------------------------- | ------------------------------ |
| Controller sınıfları gerekir          | Gerekmez                       |
| `[HttpGet]`, `[Route]` vs kullanılır  | `MapGet`, `MapPost` kullanılır |
| Startup.cs / ConfigureServices vardır | Gerekmez                       |
| Daha fazla boilerplate kod            | Daha az, sade yapı             |



Basit örnekle açıklamak gerekirse:
Diyelim bir hava durumu uygulaması var. Bu uygulama, hava durumu verilerini dışarıdan bir kaynaktan (mesela bir hava durumu servisi) almak ister.
API, bu uygulamanın dış servisle iletişim kurması için belirlenmiş kurallar ve protokoller setidir.
Uygulama API aracılığıyla servisden güncel hava durumu verisini ister, servis de uygun formatta yanıt verir.

API’nin temel özellikleri:
Veri alışverişi: Uygulamalar arası veri gönderip alma işlemini kolaylaştırır.
Standart iletişim: İki sistemin nasıl konuşacağını, hangi verileri nasıl isteyeceğini ve cevaplayacağını belirler.
Soyutlama: API kullanıcıları, sistemin iç detaylarını bilmeden işlevleri kullanabilir.
Tekrarlanabilirlik: API’ler standart olduğu için birçok uygulama tarafından tekrar tekrar kullanılabilir.

Web API Nedir?
Web API, farklı uygulamaların veya sistemlerin internet üzerinden HTTP protokolü aracılığıyla veri alışverişi yapmasını sağlayan arayüzdür.
HTTP: Web tarayıcılarının ve sunucuların kullandığı iletişim protokolüdür. (GET, POST, PUT, DELETE gibi metotları vardır.)
Web API, bu protokolü kullanarak, bir uygulamanın başka bir uygulamaya veri göndermesini veya ondan veri almasını sağlar.

Web API’nin Temel Özellikleri:
İnternet üzerinde çalışır.
Genellikle REST veya SOAP gibi standart mimariler kullanır.
Veri formatı olarak genellikle JSON veya XML kullanılır.
Platform bağımsızdır; farklı programlama dilleri ve sistemler tarafından kullanılabilir.

REST’in Temel Kavramları
Kaynak (Resource):
İnternet üzerindeki her şey bir "kaynak" olarak düşünülebilir. Örneğin; kullanıcılar, ürünler, mesajlar, siparişler birer kaynaktır.
Her kaynağın benzersiz bir URI (Uniform Resource Identifier) adresi vardır. Örnek: https://api.example.com/users/123
HTTP Metodları:
REST API, HTTP protokolündeki metodları kullanarak kaynaklar üzerinde işlem yapar.
En sık kullanılan metodlar:

GET: Veri sorgulamak (veri çekmek) için
POST: Yeni veri oluşturmak için
PUT: Var olan veriyi güncellemek için
DELETE: Veriyi silmek için
PATCH: Var olan verinin bir kısmını güncellemek için

Stateless (Durumsuzluk):
REST API, sunucunun her isteği bağımsız ve öncekilerden bağımsız olarak ele aldığı bir mimaridir.
Yani, sunucu istemcinin önceki isteklerine dair bilgiyi saklamaz. Her istek kendi içinde gerekli tüm bilgiyi taşır.

Temsiller (Representations):
Kaynaklar farklı formatlarda temsil edilebilir; en yaygınları JSON ve XML’dir.
API genellikle JSON formatında veri gönderir ve alır çünkü JSON hafiftir ve çoğu programlama dili tarafından kolay işlenir.

URI yapısı:
Kaynaklar hiyerarşik ve mantıklı URI yapıları ile tanımlanır. Örneğin:
/users → Tüm kullanıcılar
/users/5 → ID'si 5 olan kullanıcı
/users/5/orders → 5 numaralı kullanıcının siparişleri

| HTTP Metodu | İşlem                               | URI Örneği   | Açıklama                                |
| ----------- | ----------------------------------- | ------------ | --------------------------------------- |
| GET         | Veri alma                           | /products    | Tüm ürünleri listeler                   |
| GET         | Belirli veri alma                   | /products/10 | ID'si 10 olan ürünü getirir             |
| POST        | Yeni veri oluşturma                 | /products    | Yeni ürün ekler                         |
| PUT         | Var olan veriyi tamamen güncelleme  | /products/10 | ID 10 olan ürünü tamamen değiştirir     |
| PATCH       | Var olan verinin kısmını güncelleme | /products/10 | ID 10 ürünün bazı alanlarını değiştirir |
| DELETE      | Veri silme                          | /products/10 | ID 10 ürünü siler                       |

RESTful API Tasarımında İyi Pratikler
İsimlendirme: Kaynak isimleri çoğul kullanılır (/users, /orders).

HTTP durum kodları: İsteklerin sonucunu belirtmek için doğru HTTP kodları kullanılır.
Örnekler:

200 OK → Başarılı GET isteği
201 Created → Başarılı POST ile veri oluşturuldu
204 No Content → Başarılı DELETE işlemi
400 Bad Request → İstek hatalı
404 Not Found → Kaynak bulunamadı
500 Internal Server Error → Sunucu hatası

Versiyonlama: API geliştirirken sürüm yönetimi önemlidir. URI’da veya header’da versiyon belirtilir. Örnek: /api/v1/users

Filtreleme, sıralama ve sayfalama: Büyük veri setlerinde API’nin performansı ve kullanılabilirliği için desteklenir.
Örnek: /products?category=electronics&sort=price_asc&page=2

RESTful API Nasıl Çalışır? Basit Akış
İstemci (client), bir HTTP isteği gönderir (örneğin, GET /users).
Sunucu, isteği alır ve ilgili kaynağı işler.
Sunucu, isteğe karşılık JSON formatında veri döner.
İstemci dönen veriyi işler ve kullanıcıya gösterir.

Örnek JSON Yanıtı
GET /users/5 isteğine gelen örnek cevap:

{
  "id": 5,
  "name": "Atalay Özcan",
  "email": "atalay.ozcan@example.com",
  "createdAt": "2025-07-28T12:00:00Z"
}


Route Templates (Yol Şablonları) Nedir?
Web uygulamalarında, özellikle RESTful API veya MVC (Model-View-Controller) yapılarında, gelen HTTP isteklerinin hangi kod bloğuna yönlendirileceğini belirleyen URL kalıplarıdır.
Yani, URL yapısı nasıl olacak ve URL içindeki hangi parçalar (segmentler) hangi verilere karşılık gelecek, onu tanımlayan yapıdır.

Route Templates’in Alt Başlıkları
1. Route Parameters (Yol Parametreleri)
URL içerisinde değişken parçalardır.
Bu parametreler, URL'deki belirli bir bölümü temsil eder ve değer olarak dinamik bilgi alır.
Genellikle {parametreAdi} şeklinde tanımlanır. 
Örnek: /products/{id}
Burada id bir parametredir.
İstek /products/5 ise, id = 5 olarak alınır.
Bu sayede farklı ürünlerin detayları aynı route şablonuyla alınabilir.

2. Optional Parameters (Opsiyonel Parametreler)
Bazı parametrelerin zorunlu değil, isteğe bağlı olmasını sağlar.
Parametre adının sonuna ? işareti konur.
Örnek:/products/{id?}
Burada id parametresi isteğe bağlıdır.
/products/5 veya sadece /products istekleri her ikisi de geçerli olur.
Kodda, id parametresi boş (null) olabilir ve buna göre işlem yapılabilir.

Constraints (Kısıtlamalar)
Parametrelerin alabileceği değerleri sınırlamak için kullanılır.
Parametrenin sadece belirli türde veya formattaki değerleri kabul etmesini sağlar.
Route template içinde süslü parantez içine : ile kısıtlama eklenir.

Yaygın kullanılan constraint örnekleri:
| Constraint  | Açıklama                     | Örnek                    |
| ----------- | ---------------------------- | ------------------------ |
| `int`       | Sadece tam sayı kabul eder   | `{id:int}`               |
| `bool`      | Sadece boolean değer         | `{flag:bool}`            |
| `datetime`  | Tarih formatında olmalı      | `{date:datetime}`        |
| `length(3)` | En fazla 3 karakter          | `{code:length(3)}`       |
| `regex()`   | Düzenli ifadeye uygun olmalı | `{name:regex(^[a-z]+$)}` |

Özet
| Kavram              | Tanım                                                   | Örnek URL            | Açıklama                           |
| ------------------- | ------------------------------------------------------- | -------------------- | ---------------------------------- |
| Route Parameters    | URL’de dinamik veri olarak kullanılan değişken parçalar | `/users/{userId}`    | `userId` değeri URL’den alınır     |
| Optional Parameters | Zorunlu olmayan parametreler                            | `/users/{userId?}`   | `userId` olabilir veya olmayabilir |
| Constraints         | Parametrelerin değer tipini/formunu sınırlayan kural    | `/products/{id:int}` | `id` sadece tam sayı olmalı        |

//Basic Route
app.MapGet("/users/{userId}/posts/{slug}", (int userId, string slug) =>
{
    return $"User ID: {userId}, Post Slug: {slug}";
});

//Constrained Route Parameters
app.MapGet("/products/{id:int:min(1):max(100)}", (int id) =>
{
   return $"Product ID: {id}";
});

//Optional Route Parameters
app.MapGet("/reports/{year?}", (int? year = 2016) =>
{
    return $"Report of the year: {year}";
});

Catch-All Routes (Türkçesi: Yakalama Rotaları veya Tümünü Yakalama Rotaları), web uygulamalarında veya API yönlendirmelerinde, 
gelen istek URL'sinin belirli bir kalıba uymayan veya önceden tanımlanmamış tüm yolları yakalamak için kullanılan özel bir rota türüdür.

Catch-All Route Nedir?
Gelen URL’de belirtilen şablona uymayan tüm URL’leri yakalayan route (yol) şablonudur.
Genellikle daha esnek ve geniş kapsamlı yönlendirme için kullanılır.
Özellikle 404 sayfası (sayfa bulunamadı) veya dinamik içerik yükleme gibi durumlarda faydalıdır.

Nasıl Çalışır?
Normalde route’lar spesifik ve belirli kalıplara bağlıdır.
Catch-All route, URL’nin kalan tüm kısımlarını tek bir parametre olarak alır.
Bu parametre sayesinde URL’nin geri kalan kısmı string olarak elde edilir.

Örnek (ASP.NET Core’da):
// Route template: catch-all parametresi **
[Route("files/{*filepath}")]
public IActionResult GetFile(string filepath)
{
    // filepath parametresi URL'nin files sonrası tüm kısmını içerir
    return Content("İstenen dosya yolu: " + filepath);
}
/files/images/photo.jpg isteği geldiğinde:
filepath = "images/photo.jpg" olur.

/files/docs/report.pdf isteği geldiğinde:
filepath = "docs/report.pdf" olur.

Neden Kullanılır?
Dinamik sayfa veya içerik yükleme (CMS uygulamaları gibi)
Statik dosyalar veya klasör yapıları için esnek erişim
Tüm bilinmeyen URL’leri özel olarak yönetmek (404 sayfaları için)
URL parametrelerini toplu almak

| Terim           | Anlamı                                                         |
| --------------- | -------------------------------------------------------------- |
| Catch-All Route | URL’nin kalan tüm kısmını tek parametreyle yakalayan rota tipi |
| Kullanım Alanı  | Dosya yolları, dinamik içerik, 404 sayfa yönetimi              |

//Catch-all Route Parameter
app.MapGet("/files/{*filePath}", (string filePath) =>
{
    return $"Requested file path: {filePath}";
});

Query Parameters Nedir?
Query Parameters (Sorgu Parametreleri), bir HTTP isteğinde URL'nin sonunda, genellikle veri filtrelemek, sıralamak, arama yapmak veya sayfalama gibi işlemler için kullanılan anahtar-değer çiftleridir.

Yapı (Söz Dizimi):
https://example.com/products?category=electronics&sort=price_asc
Bu URL’de:
? → Sorgu parametrelerinin başladığını gösterir.
category=electronics → category adında bir parametre, değeri electronics
& → Birden fazla parametre arasında ayraç olarak kullanılır.
sort=price_asc → sort adında başka bir parametre, değeri price_asc

| Kullanım Alanı          | Açıklama                                    |
| ----------------------- | ------------------------------------------- |
| 🔍 Arama                | `?q=telefon` → "telefon" kelimesiyle ara    |
| 🗂️ Filtreleme          | `?category=books` → Sadece kitapları göster |
| 🔃 Sıralama             | `?sort=price_desc` → Fiyatına göre sırala   |
| 📄 Sayfalama            | `?page=2&limit=10` → 2. sayfa, 10 ürün      |
| 🔧 Ayarlar / seçenekler | `?showDetails=true` → Detayları göster      |

 Örnek URL ve Anlamı:
https://api.example.com/users?age=30&sort=name_desc&page=2
Anlamı:
age=30 → 30 yaşındaki kullanıcıları getir
sort=name_desc → İsme göre azalan sırala
page=2 → İkinci sayfadaki sonuçları göster

Özetle:
Query Parameters, URL’ye ? ile eklenen, veri alma isteklerinde filtreleme, arama, sıralama ve sayfalama gibi işlemleri kontrol etmemizi sağlayan anahtar-değer çiftleridir. 
Uygulamalarda API endpoint’lerine esneklik ve detaylı sorgu gücü kazandırır.

//Route with Query Parameters
app.MapGet("/search", (string? q, int page = 1) =>
{                                                              https://localhost:7053/search?q=dotnet&page=2
    return $"Searching for {q} on page {page}";
});  
**Path kısmında boşluk bırakmamaya özen göstermeli hata almadım fakat 404 çevirdi o yüzden path içinde space yapılmamalı!


CRUD API'S

The main code: 
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var blogs = new List<Blog>
{
    new Blog { Title = "First Blog", Body = "This is the body of the first blog." },
    new Blog { Title = "Second Blog", Body = "This is the body of the second blog." }
};

app.MapGet("/", () => "Hello World!");

app.MapGet("/blogs", () =>
{
    return blogs;
});

app.Run();

public class Blog
{
    public required string Title { get; set; }
    public required string Body { get; set; }
}

READ CRUDE (GET)
app.MapGet("/blogs/{id}", (int id) =>
{
    if(id >= 1 && id <= blogs.Count)
    {
        return Results.Ok(blogs[id - 1]);
    }
    else
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
});

CREATE CRUDE (POST)
//Create a new blog
app.MapPost("/blogs", (Blog blog) =>{ List nesnesi oluşturuyoruz, çünkü listeye yeni eleman eklememiz lazım. Results.Created() ASP.NET Core Minimal API’de HTTP 201 Created yanıtı döndürmek için kullanılan bir yardımcı metottur.
    blogs.Add(blog);
    return Results.Created($"/blogs/{blogs.Count -1}", blog);
});

DELETE CRUDE (DELETE)
app.MapDelete("/blogs/{id}", (int id) => {
    if(id >= 1 && id <= blogs.Count)
    {
        blogs.RemoveAt(id -1 );
        return Results.NoContent(); //204 No Content? HTTP 204 durumu, bir isteğin (genelde PUT, DELETE) başarıyla işlendiğini fakat sunucunun döndürecek içeriği olmadığını belirtir.
    }
    else    
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
});

UPDATE CRUDE (PUT)
//Update a blog
app.MapPut("/blogs/{id}", (int id, Blog blog) =>
{
    if (id >= 1 && id <= blogs.Count)
    {
        blogs[id - 1] = blog; // Update the blog at the specified index
        return Results.Ok($"Updated: {blog}");
    }
    else
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
});


HttpLogging middleware, ASP.NET Core’da istek (request) ve yanıt (response) ile ilgili HTTP bilgilerini loglamak (kayıt altına almak) için kullanılan yerleşik (built-in) bir middleware'dir.

Temel Tanım:
HttpLoggingMiddleware, HTTP trafiğini incelemek için geliştiricilere yardımcı olur.
Gelen isteğin ve giden yanıtın bazı detaylarını loglayarak hata ayıklama (debugging), performans izleme veya güvenlik analizleri için veri sağlar.

Dikkat Edilmesi Gerekenler
Geliştirme ortamında çok faydalıdır. Üretim ortamında dikkatli kullanılmalıdır çünkü:
Hassas verileri loga yazılabilir (şifre, token vb.).
Performans etkilenebilir.
Loglar şişebilir (özellikle RequestBody ve ResponseBody aktifse).

Ne Zaman Kullanılır?
API geliştirme sürecinde gelen/giden veriyi görmek istiyorsan.
Hatalı istekleri incelemek, örneğin 400 ya da 500 hatalarında ne gönderilmiş görmek istiyorsan.
Performans ya da güvenlik analizleri için log toplamak istiyorsan.
Log, güvenlik kamerası gibi: Sürekli kayıt alır, sonra açıp ne olduğunu görebilirsin.

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddHttpLogging((o) => { }); // Configure HttpLogging options if needed
var app = builder.Build();
app.UseHttpLogging();// Use the HttpLogging middleware
app.MapGet("/", () => "Hello World!");
app.Run();

Ayrıca appsetting.json dosyasının içine şu satırı ekliyoruz. 

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware": "Information" //EKLENEN SATIR
    }
  },
  "AllowedHosts": "*"
}

ASP.NET Core'da Pipeline (İşlem Boru Hattı) nedir?
ASP.NET Core’da pipeline, bir HTTP isteğinin (request) uygulamaya girdikten sonra işlem göreceği middleware zinciridir.

Bu zincirden geçen her middleware:
İsteği değiştirebilir
Kendi görevini yapabilir (örneğin loglama, yetki kontrolü)
Bir sonraki middleware'e paslayabilir
Veya zinciri burada kesebilir (örneğin hata döner)

İstek-Response Akışı (Request → Middleware → Response)
Tarayıcıdan GET /home isteği gönderilir.
Bu istek ASP.NET Core pipeline'a girer.
Sırasıyla tüm app.Use(...) middleware’leri çalışır.
Her middleware isterse:
İşlemini yapar
await next(); çağırarak bir sonrakine geçer
Sonunda bir yanıt oluşturulur (Response) ve pipeline'dan geri yukarıya doğru döner.

📦 Örnek Middleware Zinciri
app.UseHttpsRedirection();    // 1. middleware → HTTP'yi HTTPS'e yönlendirir
app.UseRouting();             // 2. middleware → URL'yi analiz eder
app.UseAuthentication();      // 3. middleware → Kimlik doğrulaması yapar
app.UseAuthorization();       // 4. middleware → Yetki kontrolü yapar
app.UseEndpoints(...);        // 5. middleware → Endpoint'i çalıştırır (örneğin controller)

Neden Bu Sistem Kullanılıyor?
Modülerlik: Her görev kendi middleware'inde tanımlanır.
Esneklik: İstediğin middleware’i kolayca ekleyebilir/çıkartabilirsin.
Kontrol: Zincirin hangi noktasında ne olduğunu görebilirsin.
Performans: Gereksiz işler yapılmaz; zincir erken kesilebilir.

Pipeline, gelen HTTP isteklerinin bir işlem tüneline (boru hattına) sokulmasıdır.
Bu tünelde her middleware kendi işini yapar veya durumu bir sonrakine devreder.

"Pipeline bir sıralama mekanizması. Önce hangi middleware'i seçeceğim, neyi yapmasını söyleyeceğim... Sıralamayı kurduğumda aslında bir pipeline yaratmış oluyorum."

app.UseMiddleware1();
app.UseMiddleware2();
app.UseMiddleware3(); gibi her app.Use(...), pipeline'a bir middleware ekler ve bu sıralama, isteğin işlenme sırasını belirler.

Basit Mantık:
Pipeline = "İstek geldiğinde şunları şu sırayla yap:"
Redirect mi edeceğim? → app.UseHttpsRedirection()
Statik dosya mı? → app.UseStaticFiles()
Rotalar çalışsın mı? → app.UseRouting()
Giriş yapıldı mı? → app.UseAuthentication()
Yetkisi var mı? → app.UseAuthorization()
Uygulama ne cevap verecek? → app.UseEndpoints(...)

Sonuç:
Pipeline: Middleware zinciridir.
Sen middleware'leri app.Use() ile sıralarsın.
Bu sıralama, her HTTP isteğinin nasıl işleneceğini belirler.
İlk gelen middleware, önce çalışır; await next() diyerek zinciri devam ettirir.
İstersen zinciri bir yerde kesebilirsin (örneğin: app.Run()).

app.Use(async (context, next) =>
{
    //logic here
    await next.Invoke();
    //logic here
});
Bu kod, app.Use(...) ile anonim (isimsiz) bir middleware tanımlar.

İşte bu yapı şunu yapar:
context → Gelen HTTP isteği (HttpContext)
next → Zincirdeki bir sonraki middleware’i temsil eder
await next.Invoke() → Zinciri bir sonrakine geçirir

Ne işe yarar?
İstek geldiğinde bu middleware çalışır.
Kendi başına bir şey yapmaz, sadece zinciri devam ettirir.
Genellikle öncesinde veya sonrasında işlem yapılır.

Yani bu custom middleware ayrıca içerisinde birden fazla mantık sırası kurabilirim.

Middleware akış sıralaması iu şekilde oluyor.

app.Use(async (context, next) =>
{
    Console.WriteLine("Before LOGİC 100");
    await next.Invoke();
    Console.WriteLine("After LOGİC 100");
});                                        İlk sırada 1)BEFORE 100 2)BEFORE 200 3)AFTER 200 4) AFTER 100 
app.Use(async (context, next) =>
{
    Console.WriteLine("Before LOGİC 200");
    await next.Invoke();
    Console.WriteLine("After LOGİC 200");
});

ControllerBase Nedir?
ControllerBase, ASP.NET Core’da sadece API geliştiren controller’lar için hazırlanmış bir soyut sınıftır (abstract class).

public class MyApiController : ControllerBase
{
    // API endpoint'leri buraya yazılır
}
Neden ControllerBase Miras Alınır?
ControllerBase, sana şu hazır yetenekleri kazandırır:
| Özellik                                                                          | Açıklama |
| -------------------------------------------------------------------------------- | -------- |
| ✅ `[Route]`, `[HttpGet]`, `[HttpPost]` gibi attribute'lar kullanılabilir olur    |          |
| ✅ `ModelState` kontrolü yapılabilir                                              |          |
| ✅ `Ok()`, `BadRequest()`, `NotFound()` gibi hazır yanıt metodları kullanılabilir |          |
| ✅ `Request`, `Response`, `User`, `HttpContext` gibi özelliklere erişim sağlanır  |          |
| ✅ `ActionResult<T>` dönüşleriyle standart API yapıları sunulur                   |          |

ASP NET CORE WEB API PRODUCT SINIFI

namespace MyFirstWebApi.Models
{
    public class Product
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public decimal Price { get; set; }
    }
}

ASP NET CORE WEB API CONTROLLER SINIFI

namespace MyFirstWebApi.Controllers
{
    using Microsoft.AspNetCore.Mvc;
    using MyFirstWebApi.Models;
    using System.Collections.Generic;
    using System.Linq;

    [Route("api/products")]
    [ApiController]
    public class ProductController : ControllerBase 
    {
        private static List<Product> products = new List<Product>();

        [HttpGet]// Route to get all products
        public ActionResult<List<Product>> GetAll() => products; // Returns all products

        
        [HttpGet("{id}")]// Route to get a product by ID
        public ActionResult<Product> GetById(int id)
        {
            var product = products.FirstOrDefault(p => p.Id == id); // Finds product by ID 
            return product !=null ? Ok(product) : NotFound(); // Returns product by ID or 404 if not found
        }

        [HttpPost] // Route to create a new product
        public ActionResult<Product> Create(Product newProduct)
        {
            newProduct.Id = products.Count + 1; // Assigns a new ID based on the current count
            products.Add(newProduct); // Adds the new product to the list
            return CreatedAtAction(nameof(GetById), new { id = newProduct.Id }, newProduct); // Returns 201 Created with the new product
        }

        [HttpPut("{id}")] // Route to update an existing product
        public ActionResult Update(int id, Product updatedProduct)
        {
            var product = products.FirstOrDefault(p => p.Id == id); // Finds product by ID
            if (product == null) return NotFound(); // Returns 404 if product not found

            product.Name = updatedProduct.Name; // Updates product properties
            product.Description = updatedProduct.Description;
            product.Price = updatedProduct.Price;
            return Ok(product); // Returns the updated product
        }

        [HttpPatch("{id}")] // Route to partially update a product
        public ActionResult MiniUpdate(int id, Product miniUpdatedProduct)
        {
            var product = products.FirstOrDefault(p => p.Id == id);
            if (product == null) return NotFound();

            product.Id = miniUpdatedProduct.Id; // Updates only the price
            return Ok(product); // Returns the updated product
        }

        [HttpDelete("{id}")] // Route to delete a product
        public ActionResult Delete(int id)
        {
            var product = products.FirstOrDefault(p => p.Id == id); // Finds product by ID
            if (product == null) return NotFound(); // Returns 404 if product not found

            products.Remove(product); // Removes the product from the list
            return NoContent(); // Returns 204 No Content
        }

    }
}

LINQ Nedir?
LINQ (Language Integrated Query) = “Dile Entegre Edilmiş Sorgu” anlamına gelir.

C# gibi .NET dillerinde;
Listeler,
Diziler,
Veritabanı tabloları,
JSON,
XML gibi veriler üzerinde
SQL'e benzer bir yapıyla arama, filtreleme, sıralama, seçme, gruplama gibi işlemleri yapmamızı sağlar.

LINQ Ne Amaçla Kullanılır?
LINQ’in amacı:

Koleksiyonlar (örneğin List<Product>) üzerinde veri işleme işlerini daha sade, okunabilir ve güvenli hale getirmektir.

Geleneksel Yöntem
List<Product> result = new List<Product>();
foreach (var p in products)
{
    if (p.Price > 1000)
        result.Add(p);
}

LINQ ile
var result = products.Where(p => p.Price > 1000).ToList();

LINQ Hangi senaryolarda gerekli?
| Senaryo                    | Açıklama                                               |
| -------------------------- | ------------------------------------------------------ |
| 🔍 **Filtreleme**          | `Where()` ile belli koşullardaki verileri seçme        |
| 🔢 **Sıralama**            | `OrderBy()` veya `OrderByDescending()`                 |
| 🔁 **Arama**               | `FirstOrDefault()`, `Find()` gibi                      |
| 📊 **Gruplama**            | `GroupBy()` kullanarak istatistik                      |
| 🎯 **Seçim / Projeksiyon** | `Select()` ile sadece bazı alanları almak              |
| 🧩 **Birleştirme (Join)**  | Farklı koleksiyonları SQL gibi birleştirme             |
| 📚 **Aggregate işlemler**  | `Count()`, `Sum()`, `Average()` gibi toplama işlemleri |

Özetle:
LINQ, daha temiz ve sade kod yazmak içindir.
Koleksiyonları sorgulamak için kullanılır.
List, Array, Dictionary, EF DbContext gibi veri koleksiyonları üzerinde işlem yaparken çok gereklidir.
Özellikle backend geliştirme, veri işleme, API ve raporlama sistemleri gibi senaryolarda neredeyse kaçınılmazdır.

Kodumda Olan Linq
FirstOrDefault
var product = products.FirstOrDefault(p => p.Id == id);
Ne yapar?
products listesinden Id'si eşleşen ilk ürünü bulur.
Yoksa null döner.

LINQ ifadelerinde genelde şu yapılar kullanılır:
Where(...) → Filtreleme (birden fazla sonucu döner)
FirstOrDefault(...) → İlk uyumlu sonucu döner, yoksa null
Any(...) → En az bir tane uyumlu eleman var mı diye bakar (bool döner)
Select(...) → Liste içinden belirli alanları seçer
OrderBy(...) / OrderByDescending(...) → Sıralama

Interface Nedir?
Interface, bir sınıfın (class) hangi metotları ve özellikleri (property) içermesi gerektiğini tanımlayan, ama kendisi bu metotların içini yazmayan (implementation içermeyen) yapıdır.

Amaç:
Sözleşme (contract) gibi düşün.
Bir interface, “Bu metotlar mutlaka bu sınıfta olacak” der.
Nasıl yapılacağı ise sınıfa bırakılır.

Neden Kullanılır?
Farklı sınıfların aynı metotları tutmasını sağlamak için.
Kodda esneklik, modülerlik ve test edilebilirlik için.
Polimorfizm (çok biçimlilik) için temel yapı.

Syntax (Örnek)
public interface IHayvan
{
    void SesCikar();
}
Burada IHayvan isimli bir interface var.
SesCikar() metodu kesinlikle bu interface’i implemente eden sınıflarda olacak ama nasıl çalışacağı sınıflara kalmış.

Interface’i Kullanan Sınıflar:
public class Kedi : IHayvan
{
    public void SesCikar()
    {
        Console.WriteLine("Miyav");
    }
}

public class Kopek : IHayvan
{
    public void SesCikar()
    {
        Console.WriteLine("Hav");
    }
}

Avantajları:
Kodun bağımlılığını azaltır (loosely coupled olur).
Farklı sınıflar aynı interface’i implemente edebilir.
Testlerde mock nesne oluşturmayı kolaylaştırır.
Büyük projelerde farklı modülleri standartlaştırır.

| Interface                       | Sınıf (Class)                          |
| ------------------------------- | -------------------------------------- |
| Sadece metot ve property imzası | Metotların ve özelliklerin içini yazar |
| Sözleşme (contract)             | Sözleşmeye uyan somut nesne            |
| Çoklu implemente edilebilir     | Tekil implementasyon                   |

readonly Nedir?
readonly, bir alanın (field) değerinin sadece:
Tanımlandığı anda (field tanımı sırasında)
Constructor (yapıcı metod) içinde
atanmasına izin verir. Bunların dışında değiştirilmesi yasaktır.

🎯 Ne İşe Yarar?
Bir değerin nesne oluşturulduktan sonra değiştirilememesini garanti altına alır.
Immutable (değişmez) nesneler veya sabitlik isteyen senaryolarda çok kullanılır.
const ile farkı: const tamamen sabittir ve compile time'da değeri bilinir, readonly ise runtime'da constructor’da belirlenebilir.

public class Product
{
    public readonly string Brand;

    public Product(string brand)
    {
        Brand = brand; // ✅ Sadece constructor içinde atanabilir
    }

    public void ChangeBrand(string newBrand)
    {
        // Brand = newBrand; ❌ Derleme hatası verir!
    }
}

const vs readonly
| Özellik             | `const`                            | `readonly`                               |
| ------------------- | ---------------------------------- | ---------------------------------------- |
| Ne zaman atanır     | Derleme zamanında (`compile time`) | Çalışma zamanında (`runtime`)            |
| Nerede atanabilir   | Tanımlandığı yerde                 | Tanımlandığı yerde veya constructor’da   |
| Değiştirilebilir mi | Hayır                              | Hayır (sadece constructor’da atanabilir) |
| Kullanım amacı      | Değişmez sabit değerler            | Nesne başına değişmeyecek değerler       |

Ne Zaman Kullanılır?
Aynı nesne için değişmemesi gereken ama farklı nesneler için farklı olabilecek değerlerde.
Örneğin id, createdAt, initialStatus gibi verilerde çok yaygındır

ÖRNEK DEPENDENCY INJECTION
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddTransient<IMyService, MyService>();

var app = builder.Build();

app.Use(async (context, next) =>
{
    var myService = context.RequestServices.GetRequiredService<IMyService>();
    myService.LogCreation("Middleware invoked First");
    await next.Invoke();
});

app.Use(async (context, next) =>
{
    var myService = context.RequestServices.GetRequiredService<IMyService>();
    myService.LogCreation("Middleware invoked Second");
    await next.Invoke();
});

app.MapGet("/", (IMyService myService) =>
{
    myService.LogCreation("MyService instance created");
    return Results.Ok("Hello, World! MyService instance created successfully.");
});

app.Run();

public interface IMyService
{
    void LogCreation(string message);
}

public class MyService : IMyService
{
    private readonly int _serviceId;

    public MyService()
    {
        _serviceId = new Random().Next(100000, 999999);
    }

    public void LogCreation(string message)
    {
        Console.WriteLine($"{message} - Service ID: {_serviceId}");
    }
}

. builder.Services.AddTransient<IMyService, MyService>();
📌 Anlamı:
Bu satırda IMyService interface’ini MyService sınıfı ile eşleştiriyoruz.
Transient olarak kaydediyoruz, yani:
Bu servis her istendiğinde yeni bir MyService örneği oluşturulacak.

📦 Neden burada yazıyoruz?
builder.Services nesnesi ASP.NET Core'un yerleşik DI konteyneridir.
AddTransient, AddScoped, AddSingleton gibi metodlarla servis yaşam süresi belirlenir.
| Yaşam Süresi | Anlamı                         |
| ------------ | ------------------------------ |
| `Transient`  | Her kullanımda yeni nesne      |
| `Scoped`     | HTTP isteği başına bir nesne   |
| `Singleton`  | Tüm uygulama boyunca tek nesne |

Interface & Sınıf: IMyService ve MyService
public interface IMyService
{
    void LogCreation(string message);
}

public class MyService : IMyService
{
    private readonly int _serviceId;

    public MyService()
    {
        _serviceId = new Random().Next(100000, 999999);
    }

    public void LogCreation(string message)
    {
        Console.WriteLine($"{message} - Service ID: {_serviceId}");
    }
}
Ne Anlama Geliyor?
IMyService: Bir interface tanımıdır. Ne yapılacağını söyler.
MyService: Onu uygulayan (implement eden) somut sınıftır. Ne yapılacağını anlatan interface’in nasıl yapılacağını içerir.

DI Neden Interface ister?
Gelecekte MyService yerine başka bir sınıf (MockMyService, LoggingService vs.) kullanılabilir.
Gevşek bağlı (loosely coupled) ve test edilebilir sistemler inşa edilir.

ÖZETLE
| Bölüm                            | Görev                                |
| -------------------------------- | ------------------------------------ |
| `builder.Services.AddTransient`  | DI sistemine kayıt (bağlantı kurma)  |
| `IMyService` interface           | Bağımlılık noktası                   |
| `MyService` class                | Somut bağımlılık (implementation)    |
| `context.RequestServices...`     | DI konteyner'dan elle alma           |
| `app.MapGet("/", (IMyService...` | DI ile doğrudan injection (otomatik) |

Middleware Kısmı
app.Use(async (context, next) =>
{
    var myService = context.RequestServices.GetRequiredService<IMyService>();
    myService.LogCreation("Middleware invoked First");
    await next.Invoke();
});
Bu app.Use(...) ne işe yarıyor?
ASP.NET Core’da app.Use(...), Middleware eklemek için kullanılır.
Middleware: HTTP isteği geldiğinde işlem yapabilen bir ara katmandır.
Bu kod, gelen her HTTP isteğinde devreye giren bir parçadır.

1. app.Use(async (context, next) => { ... })
Yeni bir anonim middleware tanımlıyoruz.
context: İsteğe dair tüm bilgileri barındıran HttpContext nesnesidir.
next: Sıradaki middleware’i temsil eder. await next.Invoke(); yazmazsak zincir kırılır.

2. var myService = context.RequestServices.GetRequiredService<IMyService>();
Bu satır ne yapar?
context.RequestServices: HTTP isteği için geçerli olan DI konteyner’ı döner.
GetRequiredService<IMyService>(): DI sisteminden IMyService tipinde bir nesne ister.

3. myService.LogCreation("Middleware invoked First");
Az önce alınan MyService nesnesinin LogCreation metodunu çağırıyoruz.
Bu sayede o middleware'in çalıştığı anda servis örneği yaratılır ve mesaj konsola yazılır.

4. await next.Invoke();
Bu satır olmazsa zincirdeki bir sonraki middleware çalışmaz.
Yani sonraki app.Use(...) veya app.MapGet(...) çalışmaz.
await ile çağrılması, asenkron işlemleri düzgün yönetmek içindir.

| Kod Parçası                        | Görevi                                     |
| ---------------------------------- | ------------------------------------------ |
| `context.RequestServices`          | O anki HTTP isteğine özel DI konteyner     |
| `GetRequiredService<IMyService>()` | Servisi konteyner'dan çek (yoksa hata ver) |
| `LogCreation(...)`                 | Servis örneğini kullandırarak işlem yap    |
| `await next.Invoke()`              | Zincirdeki bir sonraki middleware'e geç    |


try-catch Bloğu Nedir? Amacı Nedir?
try-catch, C# ve ASP.NET Core dahil birçok dilde kullanılan bir hata yakalama yapısıdır. Amaç:
Hata (exception) oluşabilecek kodları try bloğuna almak.
Hata olursa, uygulamanın çökmesini engellemek ve hata durumunu kontrol etmek.
Hatalı duruma uygun bir tepki (mesaj, log, yönlendirme, vs.) vermek.

Basit Mantığı
try
{
    // Hata çıkabilecek kodlar buraya
}
catch (Exception ex)
{
    // Hata olursa burası çalışır
}

0'A BÖLME ÖRNEĞİ
try
{
    int a = 10;
    int b = 0;
    int sonuc = a / b; // Burada hata olur
    Console.WriteLine("Sonuç: " + sonuc);
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Sıfıra bölme hatası: " + ex.Message);
}

Global Error Handling Nedir?
Global error handling (küresel hata yönetimi):
Uygulama genelinde oluşabilecek tüm hataları merkezi bir noktada yakalamayı sağlar.
Tek tek her endpoint’e try-catch yazmak yerine, ortak bir hata yakalama mekanizması kurulmuş olur.
Özellikle web projelerinde, kullanıcıya "Sunucu hatası", "Lütfen tekrar deneyin" gibi anlamlı mesajlar göstermek için kullanılır.

Örnek
app.Use(async (context, next) =>
{
    try
    {
        await next(); // İsteği bir sonraki middleware'e gönder
    }
    catch (DivideByZeroException ex)
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsJsonAsync(new { error = "Sıfıra bölme hatası oluştu!" });
    }
    catch (Exception ex)
    {
        context.Response.StatusCode = 500;
        await context.Response.WriteAsJsonAsync(new { error = "Bir hata oluştu. Lütfen tekrar deneyin." });
    }
});

// === Örnek Endpoint ===
app.MapGet("/bol", (int a, int b) =>
{
    return Results.Ok(a / b); // b = 0 girilirse hata oluşur
});

ASP.NET Core’da Logging (Kayıt Tutma) Nedir?
Logging, uygulamada olan olayların (örneğin hatalar, uyarılar, bilgi mesajları) kaydını tutmaktır. Bu sayede:
Hatalar tespit edilir,
Davranışlar izlenir,
Sistem izleme/log sunucularına veri gönderilir (örnek: Serilog, Seq, Kibana vs.).

