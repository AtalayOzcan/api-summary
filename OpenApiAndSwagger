Microsoft.AspNetCore.OpenApi ve Swashbuckle.AspNetCore NuGet'leri indirilir.

using Microsoft.AspNetCore.OpenApi;
using Swashbuckle.AspNetCore;

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
ÖRNEK ROUTE => /swagger >> https://localhost:7043/swagger

if (app.Environment.IsDevelopment())
Bu koşul, uygulamanın çalışma ortamının (environment) Development olup olmadığını kontrol eder.
ASP.NET Core uygulamalarında çalışma ortamı (Development, Staging, Production) ASPNETCORE_ENVIRONMENT ortam değişkeniyle belirlenir.
Bu sayede, sadece geliştirme aşamasında bazı özellikleri aktif edebilirsin.
Örnek: dotnet run ile çalışırken Development modunda olur, sunucuya yükleyince genelde Production olur.

app.UseSwagger()
Bu middleware, uygulamanın OpenAPI/Swagger JSON dökümantasyonunu sağlayan endpoint’i aktif eder.
Varsayılan olarak /swagger/v1/swagger.json adresinde erişilebilir.
Bu JSON, Swagger UI’nin kullanacağı ham API tanımıdır.

app.UseSwaggerUI()
Swagger UI’yi (görsel arayüz) aktif eder.
Bu arayüz sayesinde tarayıcıdan API endpoint’lerini test edebilir, dönen sonuçları görebilirsin.
Varsayılan olarak /swagger adresinden ulaşılır.


app.MapGet("/blogs/{id}", (int id) =>
{
    if (id >= 1 && id <= blogs.Count)
    {
        return Results.Ok(blogs[id - 1]);
    }
    else
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
    }).WithOpenApi(operation =>
    {
        operation.Parameters[0].Description = "The ID of the blog to retrieve";
        operation.Summary = "Get a specific blog by ID";
        operation.Description = "Returns a single blog"; 
        return operation;
    });

WithOpenApi(...) Nedir?
Bu minimal API fonksiyonu, OpenAPI (Swagger) dokümantasyonunu özelleştirmeni sağlar.
Yani endpoint’in Swagger UI üzerinde nasıl görüneceğini değiştirebilirsin.
İçine verdiğin lambda (operation => { ... }) kısmı, OpenApiOperation nesnesini alır.

operation Neyi Temsil Ediyor?
operation, OpenAPI spesifikasyonundaki Operation Object’i temsil eder.
Bu nesne, tek bir API endpoint’inin:
Parametrelerini
Açıklamasını
Özetini
Geri dönüş tiplerini vb. içerir.
Swagger UI üzerinde gördüğün her endpoint’in arkasında böyle bir operation nesnesi vardır.

operation.Parameters[0].Description
Bu, endpoint’in ilk parametresine (burada {id}) açıklama ekler.
Swagger UI’de “Parameters” bölümünde görünecek.
Burada "The ID of the blog to retrieve" şeklinde açıklama verilmiş.

operation.Summary
Endpoint’in kısa açıklaması.
Swagger UI’de endpoint başlığında görünür.
Burada "Get a specific blog by ID" olarak ayarlanmış.

operation.Description
Endpoint’in uzun açıklaması.
Swagger UI’de endpoint’in altındaki detay kısmında görünür.
Burada "Returns a single blog" şeklinde verilmiş.

4️⃣ Mantık Akışı
MapGet → /blogs/{id} endpoint’ini tanımlar.
WithOpenApi(...) → Swagger dokümantasyonunu özelleştirir.
operation → Bu endpoint’in OpenAPI içindeki tanım nesnesidir.
İçeride parametre açıklaması, kısa özet ve detay açıklama eklenir.
return operation; → Özelleştirilmiş operation geri döner ve Swagger bunu kullanır.

📌 Özet:
operation burada Swagger/OpenAPI dokümanında bu endpoint’in nasıl görüneceğini tanımlayan nesnedir.
Sen bu nesne üzerinde açıklama (Description), kısa başlık (Summary), parametre açıklamaları gibi bilgileri değiştirerek dokümantasyonu geliştiriyorsun.

**KOD**
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.OpenApi;
using Swashbuckle.AspNetCore;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddEndpointsApiExplorer();  // Endpoints API keşfini etkinleştiriyoruz. Bu, API'nizin uç noktalarını keşfetmek için kullanılır.
builder.Services.AddSwaggerGen();            // Swagger'ı ekliyoruz. Bu, API'nizin dokümantasyonunu oluşturmak için kullanılır.

var app = builder.Build();

var blogs = new List<Blog>
{
    new Blog { Title = "First Blog", Body = "This is the body of the first blog." },
    new Blog { Title = "Second Blog", Body = "This is the body of the second blog." },
};

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();   // Swagger'ı geliştirme ortamında kullanıyoruz. Bu, API'nizin dokümantasyonunu oluşturmak için kullanılır.
    app.UseSwaggerUI(); // Swagger UI'yi etkinleştiriyoruz. Bu, API'nizin dokümantasyonunu görsel olarak görüntülemek için kullanılır.
}

app.MapGet("/", () => "Hello World!").ExcludeFromDescription(); // OpenApi dokümantasyonundan hariç tutmak için kullanılır.


app.MapGet("/blogs", () =>
{
return blogs;
});

// Get a specific blog by ID, 
app.MapGet("/blogs/{id}", Results<Ok<Blog>, NotFound>(int id) => //Buradaki amaç, OpenAPI dokümantasyonunda bu endpoint'in hem başarılı hem de başarısız durumlarını gösterebilmek içindir.
{
    if (id >= 1 && id <= blogs.Count)
    {
        return TypedResults.Ok(blogs[id - 1]); // ID'ler 1'den başladığı için, liste indeksini 1 azaltıyoruz. Ve TypedResults.Ok() ile başarılı sonucu döndürüyoruz.
    }                                          // TypedResults.Ok() metodu, OpenAPI dokümantasyonunda başarılı bir yanıtı temsil eder.
    else                                       // TypedResults genel olarak, OpenAPI dokümantasyonunda daha iyi bir deneyim sunmak için kullanılır.
    {
        return TypedResults.NotFound(); 
    }
    }).WithOpenApi(operation =>
    {
        operation.Parameters[0].Description = "The ID of the blog to retrieve"; // OpenAPI dokümantasyonunda parametre açıklaması eklemek için kullanılır.
        operation.Summary = "Get a specific blog by ID";                        // OpenAPI dokümantasyonunda özet açıklama eklemek için kullanılır.
        operation.Description = "Returns a single blog";                        // OpenAPI dokümantasyonunda detaylı açıklama eklemek için kullanılır.
        return operation;
    });

//Create a new blog
app.MapPost("/blogs", (Blog blog) => {
blogs.Add(blog);
return Results.Created($"/blogs/{blogs.Count - 1}", blog);
});

//Delete a blog
app.MapDelete("/blogs/{id}", (int id) => {
if (id >= 1 && id <= blogs.Count)
{
blogs.RemoveAt(id - 1);
return Results.NoContent(); //204 No Content? HTTP 204 durumu, bir isteğin (genelde PUT, DELETE) başarıyla işlendiğini fakat sunucunun döndürecek içeriği olmadığını belirtir.
}
else
{
return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
}
});

//Update a blog
app.MapPut("/blogs/{id}", (int id, Blog blog) =>
{
if (id >= 1 && id <= blogs.Count)
{
blogs[id - 1] = blog; // Update the blog at the specified index
return Results.Ok($"Updated: {blog}");
}
else
{
return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
}
});

app.Run();

public class Blog
{
    public required string Title { get; set; }
    public required string Body { get; set; }
}


--------------------------------------------------

Ne nerede oluyor? (Zincirin akışı)
Kestrel sadece HTTP’te 5294 portunu dinliyor → app.Build() → aşağıdaki middleware’ler sırayla çalışır:

Log middleware’i

app.Use(async (ctx, next) => { await next(); if (ctx.Response.StatusCode >= 400) Console.WriteLine(...); });
Sonra çalışan middleware’lerin sonucuna bakıp 400+ ise log basıyor.

“HTTPS zorunlu” simülasyonu

if (context.Request.Query["secure"] != "true") { 400; "Simulated HTTPS Required"; return; }
URL’de ?secure=true yoksa hemen 400 döner ve zincir durur.

Girdi doğrulama (query param: input)

var input = context.Request.Query["input"];
// sadece harf/rakam; "<script>" yasak
input boş olabilir (izin veriyorsun) ya da tamamen harf/rakam olmalı. Aksi halde 400 + “Invalid Input”.

/unauthorized için erken 401

if (context.Request.Path == "/unauthorized") { 401; "Unauthorized Access"; return; }
Bu path’e gelirse zincir burada biter.

Auth simülasyonu + cookie yazma

var isAuthenticated = context.Request.Query["authenticated"] == "true";
if (!isAuthenticated) { 403; "Access Denied"; return; }
context.Response.Cookies.Append("SecureCookie", "SecureData", new CookieOptions { HttpOnly = true, Secure = true });
?authenticated=true yoksa 403.

Varsa cookie eklemeye çalışır (not: aşağıda önemli bir uyarı var).

Asenkron işlem simülasyonu
await Task.Delay(100);
await context.Response.WriteAsync("Processed Asynchronously\n");
100 ms bekler ve response’a yazar (sonraki middleware’den önce yazıyor).

Final (Run)
await context.Response.WriteAsync("Final Response from Application\n");
Eğer üstte yazı yazıldıysa (headers başladıysa) bu genelde atlanır; sen zaten HasStarted ile korumuşsun.

Hızlı test senaryoları (beklenen çıktı)
Aşağıdaki istekleri tarayıcıdan çağırabilirsin (hepsi http://localhost:5294):

✅ Tam başarılı akış
/ ?secure=true&authenticated=true&input=ABC123
Çıktı:

Processed Asynchronously
(Final yazısı gelmez; çünkü bir önceki middleware response’u başlatmış olur.)

❌ HTTPS simülasyonu yok
/
Çıktı: 400 – “Simulated HTTPS Required”
Konsolda “Security Event…” log’u görülür.

❌ Geçersiz input
/?secure=true&authenticated=true&input=abc-123 (tire geçersiz)
Çıktı: 400 – “Invalid Input”

❌ Yetkisiz yol
/unauthorized?secure=true&input=HELLO
Çıktı: 401 – “Unauthorized Access”

❌ Authentication yok
/?secure=true&input=HELLO
Çıktı: 403 – “Access Denied”

Dikkat edilmesi gerekenler / ufak hatalar
Secure cookie HTTP’de set edilmez

Sen Kestrel’i HTTP only çalıştırıyorsun ve cookie’de Secure = true.
HTTP’de tarayıcı bu cookie’yi yazmaz. Test için ya Secure=false yap, ya da gerçek hayatta olduğu gibi UseHttpsRedirection() + HTTPS portu aç.
IsValidInput için using System.Linq; eksik
input.All(char.IsLetterOrDigit) için LINQ lazım. Dosyanın başına ekle:

using System.Linq;
<script> kontrolü gereksiz
Zaten All(char.IsLetterOrDigit) ile harf/rakam dışını yasaklamışsın; <script> hiçbir şekilde geçemez. İstersen bu ekstra check’i kaldırabilirsin.
Asenkron middleware “önce yazıyor”
Şu an “Processed Asynchronously” next’ten önce yazılıyor. Bu, sonraki middleware’in header/status değiştirmesini engeller. Genelde önce await next(), sonra log/ek yanıt yazmak tercih edilir.

Öneri:
app.Use(async (ctx, next) =>
{
    await Task.Delay(100);
    await next(); // önce alt katmanlar
    if (!ctx.Response.HasStarted)
        await ctx.Response.WriteAsync("Processed Asynchronously\n");
});
HTTP→HTTPS için doğru yaklaşım
Simülasyon yerine gerçek hayatta app.UseHttpsRedirection() kullanılır; eksikse ekle.

Status code seçimleri
“HTTPS Required” için 400 yerine 307/308 redirect (veya 426 Upgrade Required) daha anlamlı.
“Unauthorized” için 401, “Forbidden” için 403 doğru (zaten öyle yapmışsın).

HasStarted kontrolü
İyi düşünmüşsün; ancak idealde tek bir middleware’in body yazması temiz olur. Diğerleri status/headers ayarlasın, body yazma işini endpoint/middleware kararıyla tek noktada tut.

MapGet ile endpoint ayrıştırma
Bazı kontrolleri sadece belirli path’lerde istiyorsan app.UseWhen / app.Map kullanarak dallandırabilirsin.

Doğrulama bağlamı
Query-string ile doğrulama/kimlik doğrulama sadece demo’da anlamlı. Gerçekte Header/Body/Token kullanılmalı (JWT, Authorization header vb.).

Hata cevabı formatı
“Invalid Input” gibi string yerine tutarlı bir JSON schema döndürmek iyi olur

{ "error": "InvalidInput", "message": "Only letters and digits allowed." }
Küçük düzenleme ile “temiz” bir versiyon (mantık aynı)
HTTPS yönlendirme kullan
Cookie’yi HTTPS’te set et

LINQ ekle
Asenkron middleware’de await next()’i önce çağır
İstersen bu örneği gerçekçi bir “health” endpoint ve JSON hata gövdesi ile birlikte refactor edip göndereyim; üstüne JWT’li ufak bir auth akışı da ekleriz.

using System;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Hosting;
using Microsoft.AspNetCore.Http;
using System.Threading.Tasks;

var builder = WebApplication.CreateBuilder(args);

// Configure to listen on HTTP only for simplicity
builder.WebHost.ConfigureKestrel(options =>
{
    options.ListenLocalhost(5294); // HTTP only
});

var app = builder.Build();

// Middleware to log security events if response status indicates an issue
app.Use(async (context, next) =>
{
    await next(); // Run the next middleware first

    if (context.Response.StatusCode >= 400)
    {
        Console.WriteLine($"Security Event: {context.Request.Path} - Status Code: {context.Response.StatusCode}");
    }
});

// Simulated HTTPS Enforcement Middleware
app.Use(async (context, next) =>
{
    // Check for a query parameter to simulate HTTPS enforcement (e.g., "?secure=true")
    if (context.Request.Query["secure"] != "true")
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsync("Simulated HTTPS Required");
        return;
    }

    await next();
});

// Middleware for input validation
app.Use(async (context, next) =>
{
    var input = context.Request.Query["input"];
    if (!IsValidInput(input))
    {
        if (!context.Response.HasStarted)
        {
            context.Response.StatusCode = 400;
            await context.Response.WriteAsync("Invalid Input");
        }
        return;
    }

    await next();
});

// Helper method for input validation
static bool IsValidInput(string input)
{
    // Checks for any unsafe characters or patterns, including "<script>"
    return string.IsNullOrEmpty(input) || (input.All(char.IsLetterOrDigit) && !input.Contains("<script>"));
}

// Middleware for short-circuiting unauthorized access
app.Use(async (context, next) =>
{
    if (context.Request.Path == "/unauthorized")
    {
        if (!context.Response.HasStarted)
        {
            context.Response.StatusCode = 401;
            await context.Response.WriteAsync("Unauthorized Access");
        }
        return; // Exit middleware pipeline early if unauthorized
    }
    await next();
});

// Middleware for simulated authentication and secure cookies
app.Use(async (context, next) =>
{
    // Simulate authentication with a query parameter (e.g., "?authenticated=true")
    var isAuthenticated = context.Request.Query["authenticated"] == "true";
    if (!isAuthenticated)
    {
        if (!context.Response.HasStarted)
        {
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync("Access Denied");
        }
        return;
    }

    context.Response.Cookies.Append("SecureCookie", "SecureData", new CookieOptions
    {
        HttpOnly = true,
        Secure = true
    });

    await next();
});

// Middleware for asynchronous processing
app.Use(async (context, next) =>
{
    await Task.Delay(100); // Simulate async operation
    if (!context.Response.HasStarted)
    {
        await context.Response.WriteAsync("Processed Asynchronously\n");
    }
    await next();
});

// Final Response Middleware
app.Run(async (context) =>
{
    if (!context.Response.HasStarted)
    {
        await context.Response.WriteAsync("Final Response from Application\n");
    }
});

app.Run(); 
