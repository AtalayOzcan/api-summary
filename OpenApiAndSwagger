Microsoft.AspNetCore.OpenApi ve Swashbuckle.AspNetCore NuGet'leri indirilir.

using Microsoft.AspNetCore.OpenApi;
using Swashbuckle.AspNetCore;

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
Ã–RNEK ROUTE => /swagger >> https://localhost:7043/swagger

if (app.Environment.IsDevelopment())
Bu koÅŸul, uygulamanÄ±n Ã§alÄ±ÅŸma ortamÄ±nÄ±n (environment) Development olup olmadÄ±ÄŸÄ±nÄ± kontrol eder.
ASP.NET Core uygulamalarÄ±nda Ã§alÄ±ÅŸma ortamÄ± (Development, Staging, Production) ASPNETCORE_ENVIRONMENT ortam deÄŸiÅŸkeniyle belirlenir.
Bu sayede, sadece geliÅŸtirme aÅŸamasÄ±nda bazÄ± Ã¶zellikleri aktif edebilirsin.
Ã–rnek: dotnet run ile Ã§alÄ±ÅŸÄ±rken Development modunda olur, sunucuya yÃ¼kleyince genelde Production olur.

app.UseSwagger()
Bu middleware, uygulamanÄ±n OpenAPI/Swagger JSON dÃ¶kÃ¼mantasyonunu saÄŸlayan endpointâ€™i aktif eder.
VarsayÄ±lan olarak /swagger/v1/swagger.json adresinde eriÅŸilebilir.
Bu JSON, Swagger UIâ€™nin kullanacaÄŸÄ± ham API tanÄ±mÄ±dÄ±r.

app.UseSwaggerUI()
Swagger UIâ€™yi (gÃ¶rsel arayÃ¼z) aktif eder.
Bu arayÃ¼z sayesinde tarayÄ±cÄ±dan API endpointâ€™lerini test edebilir, dÃ¶nen sonuÃ§larÄ± gÃ¶rebilirsin.
VarsayÄ±lan olarak /swagger adresinden ulaÅŸÄ±lÄ±r.


app.MapGet("/blogs/{id}", (int id) =>
{
    if (id >= 1 && id <= blogs.Count)
    {
        return Results.Ok(blogs[id - 1]);
    }
    else
    {
        return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
    }
    }).WithOpenApi(operation =>
    {
        operation.Parameters[0].Description = "The ID of the blog to retrieve";
        operation.Summary = "Get a specific blog by ID";
        operation.Description = "Returns a single blog"; 
        return operation;
    });

WithOpenApi(...) Nedir?
Bu minimal API fonksiyonu, OpenAPI (Swagger) dokÃ¼mantasyonunu Ã¶zelleÅŸtirmeni saÄŸlar.
Yani endpointâ€™in Swagger UI Ã¼zerinde nasÄ±l gÃ¶rÃ¼neceÄŸini deÄŸiÅŸtirebilirsin.
Ä°Ã§ine verdiÄŸin lambda (operation => { ... }) kÄ±smÄ±, OpenApiOperation nesnesini alÄ±r.

operation Neyi Temsil Ediyor?
operation, OpenAPI spesifikasyonundaki Operation Objectâ€™i temsil eder.
Bu nesne, tek bir API endpointâ€™inin:
Parametrelerini
AÃ§Ä±klamasÄ±nÄ±
Ã–zetini
Geri dÃ¶nÃ¼ÅŸ tiplerini vb. iÃ§erir.
Swagger UI Ã¼zerinde gÃ¶rdÃ¼ÄŸÃ¼n her endpointâ€™in arkasÄ±nda bÃ¶yle bir operation nesnesi vardÄ±r.

operation.Parameters[0].Description
Bu, endpointâ€™in ilk parametresine (burada {id}) aÃ§Ä±klama ekler.
Swagger UIâ€™de â€œParametersâ€ bÃ¶lÃ¼mÃ¼nde gÃ¶rÃ¼necek.
Burada "The ID of the blog to retrieve" ÅŸeklinde aÃ§Ä±klama verilmiÅŸ.

operation.Summary
Endpointâ€™in kÄ±sa aÃ§Ä±klamasÄ±.
Swagger UIâ€™de endpoint baÅŸlÄ±ÄŸÄ±nda gÃ¶rÃ¼nÃ¼r.
Burada "Get a specific blog by ID" olarak ayarlanmÄ±ÅŸ.

operation.Description
Endpointâ€™in uzun aÃ§Ä±klamasÄ±.
Swagger UIâ€™de endpointâ€™in altÄ±ndaki detay kÄ±smÄ±nda gÃ¶rÃ¼nÃ¼r.
Burada "Returns a single blog" ÅŸeklinde verilmiÅŸ.

4ï¸âƒ£ MantÄ±k AkÄ±ÅŸÄ±
MapGet â†’ /blogs/{id} endpointâ€™ini tanÄ±mlar.
WithOpenApi(...) â†’ Swagger dokÃ¼mantasyonunu Ã¶zelleÅŸtirir.
operation â†’ Bu endpointâ€™in OpenAPI iÃ§indeki tanÄ±m nesnesidir.
Ä°Ã§eride parametre aÃ§Ä±klamasÄ±, kÄ±sa Ã¶zet ve detay aÃ§Ä±klama eklenir.
return operation; â†’ Ã–zelleÅŸtirilmiÅŸ operation geri dÃ¶ner ve Swagger bunu kullanÄ±r.

ğŸ“Œ Ã–zet:
operation burada Swagger/OpenAPI dokÃ¼manÄ±nda bu endpointâ€™in nasÄ±l gÃ¶rÃ¼neceÄŸini tanÄ±mlayan nesnedir.
Sen bu nesne Ã¼zerinde aÃ§Ä±klama (Description), kÄ±sa baÅŸlÄ±k (Summary), parametre aÃ§Ä±klamalarÄ± gibi bilgileri deÄŸiÅŸtirerek dokÃ¼mantasyonu geliÅŸtiriyorsun.

**KOD**
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.OpenApi;
using Swashbuckle.AspNetCore;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddEndpointsApiExplorer();  // Endpoints API keÅŸfini etkinleÅŸtiriyoruz. Bu, API'nizin uÃ§ noktalarÄ±nÄ± keÅŸfetmek iÃ§in kullanÄ±lÄ±r.
builder.Services.AddSwaggerGen();            // Swagger'Ä± ekliyoruz. Bu, API'nizin dokÃ¼mantasyonunu oluÅŸturmak iÃ§in kullanÄ±lÄ±r.

var app = builder.Build();

var blogs = new List<Blog>
{
    new Blog { Title = "First Blog", Body = "This is the body of the first blog." },
    new Blog { Title = "Second Blog", Body = "This is the body of the second blog." },
};

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();   // Swagger'Ä± geliÅŸtirme ortamÄ±nda kullanÄ±yoruz. Bu, API'nizin dokÃ¼mantasyonunu oluÅŸturmak iÃ§in kullanÄ±lÄ±r.
    app.UseSwaggerUI(); // Swagger UI'yi etkinleÅŸtiriyoruz. Bu, API'nizin dokÃ¼mantasyonunu gÃ¶rsel olarak gÃ¶rÃ¼ntÃ¼lemek iÃ§in kullanÄ±lÄ±r.
}

app.MapGet("/", () => "Hello World!").ExcludeFromDescription(); // OpenApi dokÃ¼mantasyonundan hariÃ§ tutmak iÃ§in kullanÄ±lÄ±r.


app.MapGet("/blogs", () =>
{
return blogs;
});

// Get a specific blog by ID, 
app.MapGet("/blogs/{id}", Results<Ok<Blog>, NotFound>(int id) => //Buradaki amaÃ§, OpenAPI dokÃ¼mantasyonunda bu endpoint'in hem baÅŸarÄ±lÄ± hem de baÅŸarÄ±sÄ±z durumlarÄ±nÄ± gÃ¶sterebilmek iÃ§indir.
{
    if (id >= 1 && id <= blogs.Count)
    {
        return TypedResults.Ok(blogs[id - 1]); // ID'ler 1'den baÅŸladÄ±ÄŸÄ± iÃ§in, liste indeksini 1 azaltÄ±yoruz. Ve TypedResults.Ok() ile baÅŸarÄ±lÄ± sonucu dÃ¶ndÃ¼rÃ¼yoruz.
    }                                          // TypedResults.Ok() metodu, OpenAPI dokÃ¼mantasyonunda baÅŸarÄ±lÄ± bir yanÄ±tÄ± temsil eder.
    else                                       // TypedResults genel olarak, OpenAPI dokÃ¼mantasyonunda daha iyi bir deneyim sunmak iÃ§in kullanÄ±lÄ±r.
    {
        return TypedResults.NotFound(); 
    }
    }).WithOpenApi(operation =>
    {
        operation.Parameters[0].Description = "The ID of the blog to retrieve"; // OpenAPI dokÃ¼mantasyonunda parametre aÃ§Ä±klamasÄ± eklemek iÃ§in kullanÄ±lÄ±r.
        operation.Summary = "Get a specific blog by ID";                        // OpenAPI dokÃ¼mantasyonunda Ã¶zet aÃ§Ä±klama eklemek iÃ§in kullanÄ±lÄ±r.
        operation.Description = "Returns a single blog";                        // OpenAPI dokÃ¼mantasyonunda detaylÄ± aÃ§Ä±klama eklemek iÃ§in kullanÄ±lÄ±r.
        return operation;
    });

//Create a new blog
app.MapPost("/blogs", (Blog blog) => {
blogs.Add(blog);
return Results.Created($"/blogs/{blogs.Count - 1}", blog);
});

//Delete a blog
app.MapDelete("/blogs/{id}", (int id) => {
if (id >= 1 && id <= blogs.Count)
{
blogs.RemoveAt(id - 1);
return Results.NoContent(); //204 No Content? HTTP 204 durumu, bir isteÄŸin (genelde PUT, DELETE) baÅŸarÄ±yla iÅŸlendiÄŸini fakat sunucunun dÃ¶ndÃ¼recek iÃ§eriÄŸi olmadÄ±ÄŸÄ±nÄ± belirtir.
}
else
{
return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
}
});

//Update a blog
app.MapPut("/blogs/{id}", (int id, Blog blog) =>
{
if (id >= 1 && id <= blogs.Count)
{
blogs[id - 1] = blog; // Update the blog at the specified index
return Results.Ok($"Updated: {blog}");
}
else
{
return Results.NotFound(); //throw new ArgumentOutOfRangeException(nameof(id), "Blog not found");
}
});

app.Run();

public class Blog
{
    public required string Title { get; set; }
    public required string Body { get; set; }
}


--------------------------------------------------

Ne nerede oluyor? (Zincirin akÄ±ÅŸÄ±)
Kestrel sadece HTTPâ€™te 5294 portunu dinliyor â†’ app.Build() â†’ aÅŸaÄŸÄ±daki middlewareâ€™ler sÄ±rayla Ã§alÄ±ÅŸÄ±r:

Log middlewareâ€™i

app.Use(async (ctx, next) => { await next(); if (ctx.Response.StatusCode >= 400) Console.WriteLine(...); });
Sonra Ã§alÄ±ÅŸan middlewareâ€™lerin sonucuna bakÄ±p 400+ ise log basÄ±yor.

â€œHTTPS zorunluâ€ simÃ¼lasyonu

if (context.Request.Query["secure"] != "true") { 400; "Simulated HTTPS Required"; return; }
URLâ€™de ?secure=true yoksa hemen 400 dÃ¶ner ve zincir durur.

Girdi doÄŸrulama (query param: input)

var input = context.Request.Query["input"];
// sadece harf/rakam; "<script>" yasak
input boÅŸ olabilir (izin veriyorsun) ya da tamamen harf/rakam olmalÄ±. Aksi halde 400 + â€œInvalid Inputâ€.

/unauthorized iÃ§in erken 401

if (context.Request.Path == "/unauthorized") { 401; "Unauthorized Access"; return; }
Bu pathâ€™e gelirse zincir burada biter.

Auth simÃ¼lasyonu + cookie yazma

var isAuthenticated = context.Request.Query["authenticated"] == "true";
if (!isAuthenticated) { 403; "Access Denied"; return; }
context.Response.Cookies.Append("SecureCookie", "SecureData", new CookieOptions { HttpOnly = true, Secure = true });
?authenticated=true yoksa 403.

Varsa cookie eklemeye Ã§alÄ±ÅŸÄ±r (not: aÅŸaÄŸÄ±da Ã¶nemli bir uyarÄ± var).

Asenkron iÅŸlem simÃ¼lasyonu
await Task.Delay(100);
await context.Response.WriteAsync("Processed Asynchronously\n");
100 ms bekler ve responseâ€™a yazar (sonraki middlewareâ€™den Ã¶nce yazÄ±yor).

Final (Run)
await context.Response.WriteAsync("Final Response from Application\n");
EÄŸer Ã¼stte yazÄ± yazÄ±ldÄ±ysa (headers baÅŸladÄ±ysa) bu genelde atlanÄ±r; sen zaten HasStarted ile korumuÅŸsun.

HÄ±zlÄ± test senaryolarÄ± (beklenen Ã§Ä±ktÄ±)
AÅŸaÄŸÄ±daki istekleri tarayÄ±cÄ±dan Ã§aÄŸÄ±rabilirsin (hepsi http://localhost:5294):

âœ… Tam baÅŸarÄ±lÄ± akÄ±ÅŸ
/ ?secure=true&authenticated=true&input=ABC123
Ã‡Ä±ktÄ±:

Processed Asynchronously
(Final yazÄ±sÄ± gelmez; Ã§Ã¼nkÃ¼ bir Ã¶nceki middleware responseâ€™u baÅŸlatmÄ±ÅŸ olur.)

âŒ HTTPS simÃ¼lasyonu yok
/
Ã‡Ä±ktÄ±: 400 â€“ â€œSimulated HTTPS Requiredâ€
Konsolda â€œSecurity Eventâ€¦â€ logâ€™u gÃ¶rÃ¼lÃ¼r.

âŒ GeÃ§ersiz input
/?secure=true&authenticated=true&input=abc-123 (tire geÃ§ersiz)
Ã‡Ä±ktÄ±: 400 â€“ â€œInvalid Inputâ€

âŒ Yetkisiz yol
/unauthorized?secure=true&input=HELLO
Ã‡Ä±ktÄ±: 401 â€“ â€œUnauthorized Accessâ€

âŒ Authentication yok
/?secure=true&input=HELLO
Ã‡Ä±ktÄ±: 403 â€“ â€œAccess Deniedâ€

Dikkat edilmesi gerekenler / ufak hatalar
Secure cookie HTTPâ€™de set edilmez

Sen Kestrelâ€™i HTTP only Ã§alÄ±ÅŸtÄ±rÄ±yorsun ve cookieâ€™de Secure = true.
HTTPâ€™de tarayÄ±cÄ± bu cookieâ€™yi yazmaz. Test iÃ§in ya Secure=false yap, ya da gerÃ§ek hayatta olduÄŸu gibi UseHttpsRedirection() + HTTPS portu aÃ§.
IsValidInput iÃ§in using System.Linq; eksik
input.All(char.IsLetterOrDigit) iÃ§in LINQ lazÄ±m. DosyanÄ±n baÅŸÄ±na ekle:

using System.Linq;
<script> kontrolÃ¼ gereksiz
Zaten All(char.IsLetterOrDigit) ile harf/rakam dÄ±ÅŸÄ±nÄ± yasaklamÄ±ÅŸsÄ±n; <script> hiÃ§bir ÅŸekilde geÃ§emez. Ä°stersen bu ekstra checkâ€™i kaldÄ±rabilirsin.
Asenkron middleware â€œÃ¶nce yazÄ±yorâ€
Åu an â€œProcessed Asynchronouslyâ€ nextâ€™ten Ã¶nce yazÄ±lÄ±yor. Bu, sonraki middlewareâ€™in header/status deÄŸiÅŸtirmesini engeller. Genelde Ã¶nce await next(), sonra log/ek yanÄ±t yazmak tercih edilir.

Ã–neri:
app.Use(async (ctx, next) =>
{
    await Task.Delay(100);
    await next(); // Ã¶nce alt katmanlar
    if (!ctx.Response.HasStarted)
        await ctx.Response.WriteAsync("Processed Asynchronously\n");
});
HTTPâ†’HTTPS iÃ§in doÄŸru yaklaÅŸÄ±m
SimÃ¼lasyon yerine gerÃ§ek hayatta app.UseHttpsRedirection() kullanÄ±lÄ±r; eksikse ekle.

Status code seÃ§imleri
â€œHTTPS Requiredâ€ iÃ§in 400 yerine 307/308 redirect (veya 426 Upgrade Required) daha anlamlÄ±.
â€œUnauthorizedâ€ iÃ§in 401, â€œForbiddenâ€ iÃ§in 403 doÄŸru (zaten Ã¶yle yapmÄ±ÅŸsÄ±n).

HasStarted kontrolÃ¼
Ä°yi dÃ¼ÅŸÃ¼nmÃ¼ÅŸsÃ¼n; ancak idealde tek bir middlewareâ€™in body yazmasÄ± temiz olur. DiÄŸerleri status/headers ayarlasÄ±n, body yazma iÅŸini endpoint/middleware kararÄ±yla tek noktada tut.

MapGet ile endpoint ayrÄ±ÅŸtÄ±rma
BazÄ± kontrolleri sadece belirli pathâ€™lerde istiyorsan app.UseWhen / app.Map kullanarak dallandÄ±rabilirsin.

DoÄŸrulama baÄŸlamÄ±
Query-string ile doÄŸrulama/kimlik doÄŸrulama sadece demoâ€™da anlamlÄ±. GerÃ§ekte Header/Body/Token kullanÄ±lmalÄ± (JWT, Authorization header vb.).

Hata cevabÄ± formatÄ±
â€œInvalid Inputâ€ gibi string yerine tutarlÄ± bir JSON schema dÃ¶ndÃ¼rmek iyi olur

{ "error": "InvalidInput", "message": "Only letters and digits allowed." }
KÃ¼Ã§Ã¼k dÃ¼zenleme ile â€œtemizâ€ bir versiyon (mantÄ±k aynÄ±)
HTTPS yÃ¶nlendirme kullan
Cookieâ€™yi HTTPSâ€™te set et

LINQ ekle
Asenkron middlewareâ€™de await next()â€™i Ã¶nce Ã§aÄŸÄ±r
Ä°stersen bu Ã¶rneÄŸi gerÃ§ekÃ§i bir â€œhealthâ€ endpoint ve JSON hata gÃ¶vdesi ile birlikte refactor edip gÃ¶ndereyim; Ã¼stÃ¼ne JWTâ€™li ufak bir auth akÄ±ÅŸÄ± da ekleriz.

using System;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Hosting;
using Microsoft.AspNetCore.Http;
using System.Threading.Tasks;

var builder = WebApplication.CreateBuilder(args);

// Configure to listen on HTTP only for simplicity
builder.WebHost.ConfigureKestrel(options =>
{
    options.ListenLocalhost(5294); // HTTP only
});

var app = builder.Build();

// Middleware to log security events if response status indicates an issue
app.Use(async (context, next) =>
{
    await next(); // Run the next middleware first

    if (context.Response.StatusCode >= 400)
    {
        Console.WriteLine($"Security Event: {context.Request.Path} - Status Code: {context.Response.StatusCode}");
    }
});

// Simulated HTTPS Enforcement Middleware
app.Use(async (context, next) =>
{
    // Check for a query parameter to simulate HTTPS enforcement (e.g., "?secure=true")
    if (context.Request.Query["secure"] != "true")
    {
        context.Response.StatusCode = 400;
        await context.Response.WriteAsync("Simulated HTTPS Required");
        return;
    }

    await next();
});

// Middleware for input validation
app.Use(async (context, next) =>
{
    var input = context.Request.Query["input"];
    if (!IsValidInput(input))
    {
        if (!context.Response.HasStarted)
        {
            context.Response.StatusCode = 400;
            await context.Response.WriteAsync("Invalid Input");
        }
        return;
    }

    await next();
});

// Helper method for input validation
static bool IsValidInput(string input)
{
    // Checks for any unsafe characters or patterns, including "<script>"
    return string.IsNullOrEmpty(input) || (input.All(char.IsLetterOrDigit) && !input.Contains("<script>"));
}

// Middleware for short-circuiting unauthorized access
app.Use(async (context, next) =>
{
    if (context.Request.Path == "/unauthorized")
    {
        if (!context.Response.HasStarted)
        {
            context.Response.StatusCode = 401;
            await context.Response.WriteAsync("Unauthorized Access");
        }
        return; // Exit middleware pipeline early if unauthorized
    }
    await next();
});

// Middleware for simulated authentication and secure cookies
app.Use(async (context, next) =>
{
    // Simulate authentication with a query parameter (e.g., "?authenticated=true")
    var isAuthenticated = context.Request.Query["authenticated"] == "true";
    if (!isAuthenticated)
    {
        if (!context.Response.HasStarted)
        {
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync("Access Denied");
        }
        return;
    }

    context.Response.Cookies.Append("SecureCookie", "SecureData", new CookieOptions
    {
        HttpOnly = true,
        Secure = true
    });

    await next();
});

// Middleware for asynchronous processing
app.Use(async (context, next) =>
{
    await Task.Delay(100); // Simulate async operation
    if (!context.Response.HasStarted)
    {
        await context.Response.WriteAsync("Processed Asynchronously\n");
    }
    await next();
});

// Final Response Middleware
app.Run(async (context) =>
{
    if (!context.Response.HasStarted)
    {
        await context.Response.WriteAsync("Final Response from Application\n");
    }
});

app.Run(); 
